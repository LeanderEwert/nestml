# Generated from PyNestMLParser.g4 by ANTLR 4.7.1
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
<<<<<<< HEAD
        buf.write(u"[\u0231\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
=======
        buf.write(u"Y\u021b\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
>>>>>>> origin/synapses-feature
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t")
        buf.write(u"\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$")
        buf.write(u"\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t")
<<<<<<< HEAD
        buf.write(u",\4-\t-\4.\t.\4/\t/\3\2\3\2\3\2\3\2\3\2\3\2\5\2e\n\2")
        buf.write(u"\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3p\n\3\3\3\3\3")
        buf.write(u"\3\3\5\3u\n\3\3\3\3\3\3\3\3\3\7\3{\n\3\f\3\16\3~\13\3")
        buf.write(u"\3\4\5\4\u0081\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write(u"\5\3\5\3\5\3\5\3\5\5\5\u0090\n\5\3\5\3\5\3\5\3\5\3\5")
        buf.write(u"\3\5\3\5\5\5\u0099\n\5\3\5\3\5\3\5\3\5\5\5\u009f\n\5")
        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\7\5\u00b4\n\5\f\5\16\5\u00b7")
        buf.write(u"\13\5\3\6\3\6\3\6\3\6\5\6\u00bd\n\6\3\6\3\6\3\6\5\6\u00c2")
        buf.write(u"\n\6\3\7\3\7\3\7\5\7\u00c7\n\7\3\b\3\b\3\b\3\b\3\b\5")
        buf.write(u"\b\u00ce\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t\u00d7\n")
        buf.write(u"\t\3\n\3\n\5\n\u00db\n\n\3\13\3\13\7\13\u00df\n\13\f")
        buf.write(u"\13\16\13\u00e2\13\13\3\f\3\f\3\f\3\f\3\f\7\f\u00e9\n")
        buf.write(u"\f\f\f\16\f\u00ec\13\f\5\f\u00ee\n\f\3\f\3\f\3\r\5\r")
        buf.write(u"\u00f3\n\r\3\r\3\r\3\r\3\r\3\r\3\r\5\r\u00fb\n\r\3\16")
        buf.write(u"\3\16\3\16\3\16\5\16\u0101\n\16\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\7\17\u010c\n\17\f\17\16\17\u010f")
        buf.write(u"\13\17\3\17\5\17\u0112\n\17\3\20\3\20\7\20\u0116\n\20")
        buf.write(u"\f\20\16\20\u0119\13\20\3\21\3\21\5\21\u011d\n\21\3\22")
        buf.write(u"\3\22\3\22\5\22\u0122\n\22\3\23\3\23\3\23\3\23\5\23\u0128")
        buf.write(u"\n\23\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u0130\n\24\3")
        buf.write(u"\24\3\24\3\25\5\25\u0135\n\25\3\25\5\25\u0138\n\25\3")
        buf.write(u"\25\3\25\3\25\7\25\u013d\n\25\f\25\16\25\u0140\13\25")
        buf.write(u"\3\25\3\25\3\25\3\25\5\25\u0146\n\25\3\25\3\25\5\25\u014a")
        buf.write(u"\n\25\3\25\3\25\3\25\3\25\5\25\u0150\n\25\3\25\7\25\u0153")
        buf.write(u"\n\25\f\25\16\25\u0156\13\25\3\26\3\26\3\26\3\26\3\26")
        buf.write(u"\3\26\3\26\5\26\u015f\n\26\3\27\3\27\3\30\3\30\3\31\3")
        buf.write(u"\31\5\31\u0167\n\31\3\32\3\32\7\32\u016b\n\32\f\32\16")
        buf.write(u"\32\u016e\13\32\3\32\5\32\u0171\n\32\3\32\3\32\3\33\3")
        buf.write(u"\33\3\33\3\33\3\33\3\34\3\34\3\34\3\34\3\34\3\35\3\35")
        buf.write(u"\3\35\3\35\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\5")
        buf.write(u"\36\u018b\n\36\3\36\3\36\3\36\3\36\3\36\3\37\3\37\3\37")
        buf.write(u"\3\37\3\37\3\37\3 \3 \3 \7 \u019b\n \f \16 \u019e\13")
        buf.write(u" \3 \3 \3!\3!\3!\3!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\7")
        buf.write(u"\"\u01ae\n\"\f\"\16\"\u01b1\13\"\3\"\3\"\3#\3#\3#\3#")
        buf.write(u"\3#\3$\3$\3$\3$\3$\3$\3$\3$\7$\u01c2\n$\f$\16$\u01c5")
        buf.write(u"\13$\3$\3$\3%\3%\3%\3%\3%\3&\3&\3&\3&\3&\3\'\3\'\3\'")
        buf.write(u"\3\'\7\'\u01d7\n\'\f\'\16\'\u01da\13\'\3\'\3\'\3(\3(")
        buf.write(u"\3(\3(\3(\3)\3)\3)\3)\3)\3)\7)\u01e9\n)\f)\16)\u01ec")
        buf.write(u"\13)\3)\3)\3*\3*\3*\3*\7*\u01f4\n*\f*\16*\u01f7\13*\3")
        buf.write(u"*\3*\3+\3+\3+\3+\5+\u01ff\n+\3+\5+\u0202\n+\3+\3+\7+")
        buf.write(u"\u0206\n+\f+\16+\u0209\13+\3+\3+\5+\u020d\n+\3,\3,\5")
        buf.write(u",\u0211\n,\3-\3-\3-\3-\5-\u0217\n-\3.\3.\3.\3.\3.\3.")
        buf.write(u"\7.\u021f\n.\f.\16.\u0222\13.\5.\u0224\n.\3.\3.\5.\u0228")
        buf.write(u"\n.\3.\3.\3.\3.\3/\3/\3/\3/\2\4\4\b\60\2\4\6\b\n\f\16")
        buf.write(u"\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BD")
        buf.write(u"FHJLNPRTVXZ\\\2\5\4\2\64\64LL\3\2Z[\3\2 #\2\u0271\2d")
        buf.write(u"\3\2\2\2\4o\3\2\2\2\6\u0080\3\2\2\2\b\u008f\3\2\2\2\n")
        buf.write(u"\u00c1\3\2\2\2\f\u00c6\3\2\2\2\16\u00cd\3\2\2\2\20\u00d6")
        buf.write(u"\3\2\2\2\22\u00da\3\2\2\2\24\u00dc\3\2\2\2\26\u00e3\3")
        buf.write(u"\2\2\2\30\u00f2\3\2\2\2\32\u00fc\3\2\2\2\34\u0102\3\2")
        buf.write(u"\2\2\36\u0117\3\2\2\2 \u011c\3\2\2\2\"\u0121\3\2\2\2")
        buf.write(u"$\u0127\3\2\2\2&\u0129\3\2\2\2(\u0134\3\2\2\2*\u015e")
        buf.write(u"\3\2\2\2,\u0160\3\2\2\2.\u0162\3\2\2\2\60\u0164\3\2\2")
        buf.write(u"\2\62\u0168\3\2\2\2\64\u0174\3\2\2\2\66\u0179\3\2\2\2")
        buf.write(u"8\u017e\3\2\2\2:\u0182\3\2\2\2<\u0191\3\2\2\2>\u019c")
        buf.write(u"\3\2\2\2@\u01a1\3\2\2\2B\u01a5\3\2\2\2D\u01b4\3\2\2\2")
        buf.write(u"F\u01c3\3\2\2\2H\u01c8\3\2\2\2J\u01cd\3\2\2\2L\u01d2")
        buf.write(u"\3\2\2\2N\u01dd\3\2\2\2P\u01e2\3\2\2\2R\u01ef\3\2\2\2")
        buf.write(u"T\u01fa\3\2\2\2V\u0210\3\2\2\2X\u0212\3\2\2\2Z\u0218")
        buf.write(u"\3\2\2\2\\\u022d\3\2\2\2^e\7\t\2\2_e\7\n\2\2`e\7\13\2")
        buf.write(u"\2ae\7\f\2\2be\7\r\2\2ce\5\4\3\2d^\3\2\2\2d_\3\2\2\2")
        buf.write(u"d`\3\2\2\2da\3\2\2\2db\3\2\2\2dc\3\2\2\2e\3\3\2\2\2f")
        buf.write(u"g\b\3\1\2gh\7\62\2\2hi\5\4\3\2ij\7\63\2\2jp\3\2\2\2k")
        buf.write(u"l\7Z\2\2lm\7P\2\2mp\5\4\3\4np\7Y\2\2of\3\2\2\2ok\3\2")
        buf.write(u"\2\2on\3\2\2\2p|\3\2\2\2qt\f\5\2\2ru\7N\2\2su\7P\2\2")
        buf.write(u"tr\3\2\2\2ts\3\2\2\2uv\3\2\2\2v{\5\4\3\6wx\f\6\2\2xy")
        buf.write(u"\7O\2\2y{\5\6\4\2zq\3\2\2\2zw\3\2\2\2{~\3\2\2\2|z\3\2")
        buf.write(u"\2\2|}\3\2\2\2}\5\3\2\2\2~|\3\2\2\2\177\u0081\t\2\2\2")
        buf.write(u"\u0080\177\3\2\2\2\u0080\u0081\3\2\2\2\u0081\u0082\3")
        buf.write(u"\2\2\2\u0082\u0083\7Z\2\2\u0083\7\3\2\2\2\u0084\u0085")
        buf.write(u"\b\5\1\2\u0085\u0086\7\62\2\2\u0086\u0087\5\b\5\2\u0087")
        buf.write(u"\u0088\7\63\2\2\u0088\u0090\3\2\2\2\u0089\u008a\5\f\7")
        buf.write(u"\2\u008a\u008b\5\b\5\13\u008b\u0090\3\2\2\2\u008c\u008d")
        buf.write(u"\7\33\2\2\u008d\u0090\5\b\5\6\u008e\u0090\5\n\6\2\u008f")
        buf.write(u"\u0084\3\2\2\2\u008f\u0089\3\2\2\2\u008f\u008c\3\2\2")
        buf.write(u"\2\u008f\u008e\3\2\2\2\u0090\u00b5\3\2\2\2\u0091\u0092")
        buf.write(u"\f\f\2\2\u0092\u0093\7O\2\2\u0093\u00b4\5\b\5\f\u0094")
        buf.write(u"\u0098\f\n\2\2\u0095\u0099\7N\2\2\u0096\u0099\7P\2\2")
        buf.write(u"\u0097\u0099\7Q\2\2\u0098\u0095\3\2\2\2\u0098\u0096\3")
        buf.write(u"\2\2\2\u0098\u0097\3\2\2\2\u0099\u009a\3\2\2\2\u009a")
        buf.write(u"\u00b4\5\b\5\13\u009b\u009e\f\t\2\2\u009c\u009f\7\64")
        buf.write(u"\2\2\u009d\u009f\7L\2\2\u009e\u009c\3\2\2\2\u009e\u009d")
        buf.write(u"\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00b4\5\b\5\n\u00a1")
        buf.write(u"\u00a2\f\b\2\2\u00a2\u00a3\5\16\b\2\u00a3\u00a4\5\b\5")
        buf.write(u"\t\u00a4\u00b4\3\2\2\2\u00a5\u00a6\f\7\2\2\u00a6\u00a7")
        buf.write(u"\5\20\t\2\u00a7\u00a8\5\b\5\b\u00a8\u00b4\3\2\2\2\u00a9")
        buf.write(u"\u00aa\f\5\2\2\u00aa\u00ab\5\22\n\2\u00ab\u00ac\5\b\5")
        buf.write(u"\6\u00ac\u00b4\3\2\2\2\u00ad\u00ae\f\4\2\2\u00ae\u00af")
        buf.write(u"\7R\2\2\u00af\u00b0\5\b\5\2\u00b0\u00b1\7S\2\2\u00b1")
        buf.write(u"\u00b2\5\b\5\5\u00b2\u00b4\3\2\2\2\u00b3\u0091\3\2\2")
        buf.write(u"\2\u00b3\u0094\3\2\2\2\u00b3\u009b\3\2\2\2\u00b3\u00a1")
        buf.write(u"\3\2\2\2\u00b3\u00a5\3\2\2\2\u00b3\u00a9\3\2\2\2\u00b3")
        buf.write(u"\u00ad\3\2\2\2\u00b4\u00b7\3\2\2\2\u00b5\u00b3\3\2\2")
        buf.write(u"\2\u00b5\u00b6\3\2\2\2\u00b6\t\3\2\2\2\u00b7\u00b5\3")
        buf.write(u"\2\2\2\u00b8\u00c2\5\26\f\2\u00b9\u00c2\7W\2\2\u00ba")
        buf.write(u"\u00bc\t\3\2\2\u00bb\u00bd\5\24\13\2\u00bc\u00bb\3\2")
        buf.write(u"\2\2\u00bc\u00bd\3\2\2\2\u00bd\u00c2\3\2\2\2\u00be\u00c2")
        buf.write(u"\7X\2\2\u00bf\u00c2\7\30\2\2\u00c0\u00c2\5\24\13\2\u00c1")
        buf.write(u"\u00b8\3\2\2\2\u00c1\u00b9\3\2\2\2\u00c1\u00ba\3\2\2")
        buf.write(u"\2\u00c1\u00be\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c1\u00c0")
        buf.write(u"\3\2\2\2\u00c2\13\3\2\2\2\u00c3\u00c7\7\64\2\2\u00c4")
        buf.write(u"\u00c7\7L\2\2\u00c5\u00c7\7\65\2\2\u00c6\u00c3\3\2\2")
        buf.write(u"\2\u00c6\u00c4\3\2\2\2\u00c6\u00c5\3\2\2\2\u00c7\r\3")
        buf.write(u"\2\2\2\u00c8\u00ce\78\2\2\u00c9\u00ce\7\67\2\2\u00ca")
        buf.write(u"\u00ce\7\66\2\2\u00cb\u00ce\7>\2\2\u00cc\u00ce\7?\2\2")
        buf.write(u"\u00cd\u00c8\3\2\2\2\u00cd\u00c9\3\2\2\2\u00cd\u00ca")
        buf.write(u"\3\2\2\2\u00cd\u00cb\3\2\2\2\u00cd\u00cc\3\2\2\2\u00ce")
        buf.write(u"\17\3\2\2\2\u00cf\u00d7\7@\2\2\u00d0\u00d7\7B\2\2\u00d1")
        buf.write(u"\u00d7\7G\2\2\u00d2\u00d7\7H\2\2\u00d3\u00d7\7I\2\2\u00d4")
        buf.write(u"\u00d7\7J\2\2\u00d5\u00d7\7A\2\2\u00d6\u00cf\3\2\2\2")
        buf.write(u"\u00d6\u00d0\3\2\2\2\u00d6\u00d1\3\2\2\2\u00d6\u00d2")
        buf.write(u"\3\2\2\2\u00d6\u00d3\3\2\2\2\u00d6\u00d4\3\2\2\2\u00d6")
        buf.write(u"\u00d5\3\2\2\2\u00d7\21\3\2\2\2\u00d8\u00db\7\31\2\2")
        buf.write(u"\u00d9\u00db\7\32\2\2\u00da\u00d8\3\2\2\2\u00da\u00d9")
        buf.write(u"\3\2\2\2\u00db\23\3\2\2\2\u00dc\u00e0\7Y\2\2\u00dd\u00df")
        buf.write(u"\7V\2\2\u00de\u00dd\3\2\2\2\u00df\u00e2\3\2\2\2\u00e0")
        buf.write(u"\u00de\3\2\2\2\u00e0\u00e1\3\2\2\2\u00e1\25\3\2\2\2\u00e2")
        buf.write(u"\u00e0\3\2\2\2\u00e3\u00e4\7Y\2\2\u00e4\u00ed\7\62\2")
        buf.write(u"\2\u00e5\u00ea\5\b\5\2\u00e6\u00e7\7K\2\2\u00e7\u00e9")
        buf.write(u"\5\b\5\2\u00e8\u00e6\3\2\2\2\u00e9\u00ec\3\2\2\2\u00ea")
        buf.write(u"\u00e8\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u00ee\3\2\2")
        buf.write(u"\2\u00ec\u00ea\3\2\2\2\u00ed\u00e5\3\2\2\2\u00ed\u00ee")
        buf.write(u"\3\2\2\2\u00ee\u00ef\3\2\2\2\u00ef\u00f0\7\63\2\2\u00f0")
        buf.write(u"\27\3\2\2\2\u00f1\u00f3\7\34\2\2\u00f2\u00f1\3\2\2\2")
        buf.write(u"\u00f2\u00f3\3\2\2\2\u00f3\u00f4\3\2\2\2\u00f4\u00f5")
        buf.write(u"\7\17\2\2\u00f5\u00f6\7Y\2\2\u00f6\u00f7\5\2\2\2\u00f7")
        buf.write(u"\u00f8\7M\2\2\u00f8\u00fa\5\b\5\2\u00f9\u00fb\7U\2\2")
        buf.write(u"\u00fa\u00f9\3\2\2\2\u00fa\u00fb\3\2\2\2\u00fb\31\3\2")
        buf.write(u"\2\2\u00fc\u00fd\5\24\13\2\u00fd\u00fe\7M\2\2\u00fe\u0100")
        buf.write(u"\5\b\5\2\u00ff\u0101\7U\2\2\u0100\u00ff\3\2\2\2\u0100")
        buf.write(u"\u0101\3\2\2\2\u0101\33\3\2\2\2\u0102\u0103\7\35\2\2")
        buf.write(u"\u0103\u0104\5\24\13\2\u0104\u0105\7M\2\2\u0105\u010d")
        buf.write(u"\5\b\5\2\u0106\u0107\7K\2\2\u0107\u0108\5\24\13\2\u0108")
        buf.write(u"\u0109\7M\2\2\u0109\u010a\5\b\5\2\u010a\u010c\3\2\2\2")
        buf.write(u"\u010b\u0106\3\2\2\2\u010c\u010f\3\2\2\2\u010d\u010b")
        buf.write(u"\3\2\2\2\u010d\u010e\3\2\2\2\u010e\u0111\3\2\2\2\u010f")
        buf.write(u"\u010d\3\2\2\2\u0110\u0112\7U\2\2\u0111\u0110\3\2\2\2")
        buf.write(u"\u0111\u0112\3\2\2\2\u0112\35\3\2\2\2\u0113\u0116\5 ")
        buf.write(u"\21\2\u0114\u0116\7\5\2\2\u0115\u0113\3\2\2\2\u0115\u0114")
        buf.write(u"\3\2\2\2\u0116\u0119\3\2\2\2\u0117\u0115\3\2\2\2\u0117")
        buf.write(u"\u0118\3\2\2\2\u0118\37\3\2\2\2\u0119\u0117\3\2\2\2\u011a")
        buf.write(u"\u011d\5$\23\2\u011b\u011d\5\"\22\2\u011c\u011a\3\2\2")
        buf.write(u"\2\u011c\u011b\3\2\2\2\u011d!\3\2\2\2\u011e\u0122\5\62")
        buf.write(u"\32\2\u011f\u0122\5:\36\2\u0120\u0122\5<\37\2\u0121\u011e")
        buf.write(u"\3\2\2\2\u0121\u011f\3\2\2\2\u0121\u0120\3\2\2\2\u0122")
        buf.write(u"#\3\2\2\2\u0123\u0128\5&\24\2\u0124\u0128\5\26\f\2\u0125")
        buf.write(u"\u0128\5(\25\2\u0126\u0128\5\60\31\2\u0127\u0123\3\2")
        buf.write(u"\2\2\u0127\u0124\3\2\2\2\u0127\u0125\3\2\2\2\u0127\u0126")
        buf.write(u"\3\2\2\2\u0128%\3\2\2\2\u0129\u012f\5\24\13\2\u012a\u0130")
        buf.write(u"\7M\2\2\u012b\u0130\7C\2\2\u012c\u0130\7D\2\2\u012d\u0130")
        buf.write(u"\7E\2\2\u012e\u0130\7F\2\2\u012f\u012a\3\2\2\2\u012f")
        buf.write(u"\u012b\3\2\2\2\u012f\u012c\3\2\2\2\u012f\u012d\3\2\2")
        buf.write(u"\2\u012f\u012e\3\2\2\2\u0130\u0131\3\2\2\2\u0131\u0132")
        buf.write(u"\5\b\5\2\u0132\'\3\2\2\2\u0133\u0135\7\34\2\2\u0134\u0133")
        buf.write(u"\3\2\2\2\u0134\u0135\3\2\2\2\u0135\u0137\3\2\2\2\u0136")
        buf.write(u"\u0138\7\16\2\2\u0137\u0136\3\2\2\2\u0137\u0138\3\2\2")
        buf.write(u"\2\u0138\u0139\3\2\2\2\u0139\u013e\5\24\13\2\u013a\u013b")
        buf.write(u"\7K\2\2\u013b\u013d\5\24\13\2\u013c\u013a\3\2\2\2\u013d")
        buf.write(u"\u0140\3\2\2\2\u013e\u013c\3\2\2\2\u013e\u013f\3\2\2")
        buf.write(u"\2\u013f\u0141\3\2\2\2\u0140\u013e\3\2\2\2\u0141\u0145")
        buf.write(u"\5\2\2\2\u0142\u0143\79\2\2\u0143\u0144\7Y\2\2\u0144")
        buf.write(u"\u0146\7;\2\2\u0145\u0142\3\2\2\2\u0145\u0146\3\2\2\2")
        buf.write(u"\u0146\u0149\3\2\2\2\u0147\u0148\7M\2\2\u0148\u014a\5")
        buf.write(u"\b\5\2\u0149\u0147\3\2\2\2\u0149\u014a\3\2\2\2\u014a")
        buf.write(u"\u014f\3\2\2\2\u014b\u014c\7<\2\2\u014c\u014d\5\b\5\2")
        buf.write(u"\u014d\u014e\7=\2\2\u014e\u0150\3\2\2\2\u014f\u014b\3")
        buf.write(u"\2\2\2\u014f\u0150\3\2\2\2\u0150\u0154\3\2\2\2\u0151")
        buf.write(u"\u0153\5*\26\2\u0152\u0151\3\2\2\2\u0153\u0156\3\2\2")
        buf.write(u"\2\u0154\u0152\3\2\2\2\u0154\u0155\3\2\2\2\u0155)\3\2")
        buf.write(u"\2\2\u0156\u0154\3\2\2\2\u0157\u015f\7.\2\2\u0158\u015f")
        buf.write(u"\7/\2\2\u0159\u015a\7\60\2\2\u015a\u015b\5,\27\2\u015b")
        buf.write(u"\u015c\7T\2\2\u015c\u015d\5.\30\2\u015d\u015f\3\2\2\2")
        buf.write(u"\u015e\u0157\3\2\2\2\u015e\u0158\3\2\2\2\u015e\u0159")
        buf.write(u"\3\2\2\2\u015f+\3\2\2\2\u0160\u0161\7Y\2\2\u0161-\3\2")
        buf.write(u"\2\2\u0162\u0163\7Y\2\2\u0163/\3\2\2\2\u0164\u0166\7")
        buf.write(u"\20\2\2\u0165\u0167\5\b\5\2\u0166\u0165\3\2\2\2\u0166")
        buf.write(u"\u0167\3\2\2\2\u0167\61\3\2\2\2\u0168\u016c\5\64\33\2")
        buf.write(u"\u0169\u016b\5\66\34\2\u016a\u0169\3\2\2\2\u016b\u016e")
        buf.write(u"\3\2\2\2\u016c\u016a\3\2\2\2\u016c\u016d\3\2\2\2\u016d")
        buf.write(u"\u0170\3\2\2\2\u016e\u016c\3\2\2\2\u016f\u0171\58\35")
        buf.write(u"\2\u0170\u016f\3\2\2\2\u0170\u0171\3\2\2\2\u0171\u0172")
        buf.write(u"\3\2\2\2\u0172\u0173\7\b\2\2\u0173\63\3\2\2\2\u0174\u0175")
        buf.write(u"\7\21\2\2\u0175\u0176\5\b\5\2\u0176\u0177\7S\2\2\u0177")
        buf.write(u"\u0178\5\36\20\2\u0178\65\3\2\2\2\u0179\u017a\7\22\2")
        buf.write(u"\2\u017a\u017b\5\b\5\2\u017b\u017c\7S\2\2\u017c\u017d")
        buf.write(u"\5\36\20\2\u017d\67\3\2\2\2\u017e\u017f\7\23\2\2\u017f")
        buf.write(u"\u0180\7S\2\2\u0180\u0181\5\36\20\2\u01819\3\2\2\2\u0182")
        buf.write(u"\u0183\7\24\2\2\u0183\u0184\7Y\2\2\u0184\u0185\7\26\2")
        buf.write(u"\2\u0185\u0186\5\b\5\2\u0186\u0187\7\61\2\2\u0187\u0188")
        buf.write(u"\5\b\5\2\u0188\u018a\7\27\2\2\u0189\u018b\7L\2\2\u018a")
        buf.write(u"\u0189\3\2\2\2\u018a\u018b\3\2\2\2\u018b\u018c\3\2\2")
        buf.write(u"\2\u018c\u018d\t\3\2\2\u018d\u018e\7S\2\2\u018e\u018f")
        buf.write(u"\5\36\20\2\u018f\u0190\7\b\2\2\u0190;\3\2\2\2\u0191\u0192")
        buf.write(u"\7\25\2\2\u0192\u0193\5\b\5\2\u0193\u0194\7S\2\2\u0194")
        buf.write(u"\u0195\5\36\20\2\u0195\u0196\7\b\2\2\u0196=\3\2\2\2\u0197")
        buf.write(u"\u019b\5@!\2\u0198\u019b\5D#\2\u0199\u019b\7\5\2\2\u019a")
        buf.write(u"\u0197\3\2\2\2\u019a\u0198\3\2\2\2\u019a\u0199\3\2\2")
        buf.write(u"\2\u019b\u019e\3\2\2\2\u019c\u019a\3\2\2\2\u019c\u019d")
        buf.write(u"\3\2\2\2\u019d\u019f\3\2\2\2\u019e\u019c\3\2\2\2\u019f")
        buf.write(u"\u01a0\7\2\2\3\u01a0?\3\2\2\2\u01a1\u01a2\7\36\2\2\u01a2")
        buf.write(u"\u01a3\7Y\2\2\u01a3\u01a4\5B\"\2\u01a4A\3\2\2\2\u01a5")
        buf.write(u"\u01af\7S\2\2\u01a6\u01ae\7\5\2\2\u01a7\u01ae\5L\'\2")
        buf.write(u"\u01a8\u01ae\5P)\2\u01a9\u01ae\5R*\2\u01aa\u01ae\5X-")
        buf.write(u"\2\u01ab\u01ae\5N(\2\u01ac\u01ae\5Z.\2\u01ad\u01a6\3")
        buf.write(u"\2\2\2\u01ad\u01a7\3\2\2\2\u01ad\u01a8\3\2\2\2\u01ad")
        buf.write(u"\u01a9\3\2\2\2\u01ad\u01aa\3\2\2\2\u01ad\u01ab\3\2\2")
        buf.write(u"\2\u01ad\u01ac\3\2\2\2\u01ae\u01b1\3\2\2\2\u01af\u01ad")
        buf.write(u"\3\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01b2\3\2\2\2\u01b1")
        buf.write(u"\u01af\3\2\2\2\u01b2\u01b3\7\b\2\2\u01b3C\3\2\2\2\u01b4")
        buf.write(u"\u01b5\7\37\2\2\u01b5\u01b6\7Y\2\2\u01b6\u01b7\7S\2\2")
        buf.write(u"\u01b7\u01b8\5F$\2\u01b8E\3\2\2\2\u01b9\u01c2\7\5\2\2")
        buf.write(u"\u01ba\u01c2\5L\'\2\u01bb\u01c2\5P)\2\u01bc\u01c2\5R")
        buf.write(u"*\2\u01bd\u01c2\5N(\2\u01be\u01c2\5Z.\2\u01bf\u01c2\5")
        buf.write(u"H%\2\u01c0\u01c2\5J&\2\u01c1\u01b9\3\2\2\2\u01c1\u01ba")
        buf.write(u"\3\2\2\2\u01c1\u01bb\3\2\2\2\u01c1\u01bc\3\2\2\2\u01c1")
        buf.write(u"\u01bd\3\2\2\2\u01c1\u01be\3\2\2\2\u01c1\u01bf\3\2\2")
        buf.write(u"\2\u01c1\u01c0\3\2\2\2\u01c2\u01c5\3\2\2\2\u01c3\u01c1")
        buf.write(u"\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4\u01c6\3\2\2\2\u01c5")
        buf.write(u"\u01c3\3\2\2\2\u01c6\u01c7\7\b\2\2\u01c7G\3\2\2\2\u01c8")
        buf.write(u"\u01c9\7(\2\2\u01c9\u01ca\7S\2\2\u01ca\u01cb\5\36\20")
        buf.write(u"\2\u01cb\u01cc\7\b\2\2\u01ccI\3\2\2\2\u01cd\u01ce\7)")
        buf.write(u"\2\2\u01ce\u01cf\7S\2\2\u01cf\u01d0\5\36\20\2\u01d0\u01d1")
        buf.write(u"\7\b\2\2\u01d1K\3\2\2\2\u01d2\u01d3\t\4\2\2\u01d3\u01d8")
        buf.write(u"\7S\2\2\u01d4\u01d7\5(\25\2\u01d5\u01d7\7\5\2\2\u01d6")
        buf.write(u"\u01d4\3\2\2\2\u01d6\u01d5\3\2\2\2\u01d7\u01da\3\2\2")
        buf.write(u"\2\u01d8\u01d6\3\2\2\2\u01d8\u01d9\3\2\2\2\u01d9\u01db")
        buf.write(u"\3\2\2\2\u01da\u01d8\3\2\2\2\u01db\u01dc\7\b\2\2\u01dc")
        buf.write(u"M\3\2\2\2\u01dd\u01de\7$\2\2\u01de\u01df\7S\2\2\u01df")
        buf.write(u"\u01e0\5\36\20\2\u01e0\u01e1\7\b\2\2\u01e1O\3\2\2\2\u01e2")
        buf.write(u"\u01e3\7%\2\2\u01e3\u01ea\7S\2\2\u01e4\u01e9\5\30\r\2")
        buf.write(u"\u01e5\u01e9\5\32\16\2\u01e6\u01e9\5\34\17\2\u01e7\u01e9")
        buf.write(u"\7\5\2\2\u01e8\u01e4\3\2\2\2\u01e8\u01e5\3\2\2\2\u01e8")
        buf.write(u"\u01e6\3\2\2\2\u01e8\u01e7\3\2\2\2\u01e9\u01ec\3\2\2")
        buf.write(u"\2\u01ea\u01e8\3\2\2\2\u01ea\u01eb\3\2\2\2\u01eb\u01ed")
        buf.write(u"\3\2\2\2\u01ec\u01ea\3\2\2\2\u01ed\u01ee\7\b\2\2\u01ee")
        buf.write(u"Q\3\2\2\2\u01ef\u01f0\7&\2\2\u01f0\u01f5\7S\2\2\u01f1")
        buf.write(u"\u01f4\5T+\2\u01f2\u01f4\7\5\2\2\u01f3\u01f1\3\2\2\2")
        buf.write(u"\u01f3\u01f2\3\2\2\2\u01f4\u01f7\3\2\2\2\u01f5\u01f3")
        buf.write(u"\3\2\2\2\u01f5\u01f6\3\2\2\2\u01f6\u01f8\3\2\2\2\u01f7")
        buf.write(u"\u01f5\3\2\2\2\u01f8\u01f9\7\b\2\2\u01f9S\3\2\2\2\u01fa")
        buf.write(u"\u01fe\7Y\2\2\u01fb\u01fc\79\2\2\u01fc\u01fd\7Y\2\2\u01fd")
        buf.write(u"\u01ff\7;\2\2\u01fe\u01fb\3\2\2\2\u01fe\u01ff\3\2\2\2")
        buf.write(u"\u01ff\u0201\3\2\2\2\u0200\u0202\5\2\2\2\u0201\u0200")
        buf.write(u"\3\2\2\2\u0201\u0202\3\2\2\2\u0202\u0203\3\2\2\2\u0203")
        buf.write(u"\u0207\7:\2\2\u0204\u0206\5V,\2\u0205\u0204\3\2\2\2\u0206")
        buf.write(u"\u0209\3\2\2\2\u0207\u0205\3\2\2\2\u0207\u0208\3\2\2")
        buf.write(u"\2\u0208\u020c\3\2\2\2\u0209\u0207\3\2\2\2\u020a\u020d")
        buf.write(u"\7*\2\2\u020b\u020d\7+\2\2\u020c\u020a\3\2\2\2\u020c")
        buf.write(u"\u020b\3\2\2\2\u020dU\3\2\2\2\u020e\u0211\7,\2\2\u020f")
        buf.write(u"\u0211\7-\2\2\u0210\u020e\3\2\2\2\u0210\u020f\3\2\2\2")
        buf.write(u"\u0211W\3\2\2\2\u0212\u0213\7\'\2\2\u0213\u0216\7S\2")
        buf.write(u"\2\u0214\u0217\7+\2\2\u0215\u0217\7*\2\2\u0216\u0214")
        buf.write(u"\3\2\2\2\u0216\u0215\3\2\2\2\u0217Y\3\2\2\2\u0218\u0219")
        buf.write(u"\7\16\2\2\u0219\u021a\7Y\2\2\u021a\u0223\7\62\2\2\u021b")
        buf.write(u"\u0220\5\\/\2\u021c\u021d\7K\2\2\u021d\u021f\5\\/\2\u021e")
        buf.write(u"\u021c\3\2\2\2\u021f\u0222\3\2\2\2\u0220\u021e\3\2\2")
        buf.write(u"\2\u0220\u0221\3\2\2\2\u0221\u0224\3\2\2\2\u0222\u0220")
        buf.write(u"\3\2\2\2\u0223\u021b\3\2\2\2\u0223\u0224\3\2\2\2\u0224")
        buf.write(u"\u0225\3\2\2\2\u0225\u0227\7\63\2\2\u0226\u0228\5\2\2")
        buf.write(u"\2\u0227\u0226\3\2\2\2\u0227\u0228\3\2\2\2\u0228\u0229")
        buf.write(u"\3\2\2\2\u0229\u022a\7S\2\2\u022a\u022b\5\36\20\2\u022b")
        buf.write(u"\u022c\7\b\2\2\u022c[\3\2\2\2\u022d\u022e\7Y\2\2\u022e")
        buf.write(u"\u022f\5\2\2\2\u022f]\3\2\2\2Bdotz|\u0080\u008f\u0098")
        buf.write(u"\u009e\u00b3\u00b5\u00bc\u00c1\u00c6\u00cd\u00d6\u00da")
        buf.write(u"\u00e0\u00ea\u00ed\u00f2\u00fa\u0100\u010d\u0111\u0115")
        buf.write(u"\u0117\u011c\u0121\u0127\u012f\u0134\u0137\u013e\u0145")
        buf.write(u"\u0149\u014f\u0154\u015e\u0166\u016c\u0170\u018a\u019a")
        buf.write(u"\u019c\u01ad\u01af\u01c1\u01c3\u01d6\u01d8\u01e8\u01ea")
        buf.write(u"\u01f3\u01f5\u01fe\u0201\u0207\u020c\u0210\u0216\u0220")
        buf.write(u"\u0223\u0227")
=======
        buf.write(u",\4-\t-\4.\t.\3\2\3\2\3\2\3\2\3\2\3\2\5\2c\n\2\3\3\3")
        buf.write(u"\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3n\n\3\3\3\3\3\3\3\5")
        buf.write(u"\3s\n\3\3\3\3\3\3\3\3\3\7\3y\n\3\f\3\16\3|\13\3\3\4\5")
        buf.write(u"\4\177\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write(u"\5\3\5\3\5\5\5\u008e\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write(u"\5\5\u0097\n\5\3\5\3\5\3\5\3\5\5\5\u009d\n\5\3\5\3\5")
        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write(u"\3\5\3\5\3\5\3\5\7\5\u00b2\n\5\f\5\16\5\u00b5\13\5\3")
        buf.write(u"\6\3\6\3\6\3\6\5\6\u00bb\n\6\3\6\3\6\3\6\5\6\u00c0\n")
        buf.write(u"\6\3\7\3\7\3\7\5\7\u00c5\n\7\3\b\3\b\3\b\3\b\3\b\5\b")
        buf.write(u"\u00cc\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t\u00d5\n\t")
        buf.write(u"\3\n\3\n\5\n\u00d9\n\n\3\13\3\13\7\13\u00dd\n\13\f\13")
        buf.write(u"\16\13\u00e0\13\13\3\f\3\f\3\f\3\f\3\f\7\f\u00e7\n\f")
        buf.write(u"\f\f\16\f\u00ea\13\f\5\f\u00ec\n\f\3\f\3\f\3\r\5\r\u00f1")
        buf.write(u"\n\r\3\r\3\r\3\r\3\r\3\r\3\r\5\r\u00f9\n\r\3\16\3\16")
        buf.write(u"\3\16\3\16\5\16\u00ff\n\16\3\17\3\17\3\17\3\17\3\17\5")
        buf.write(u"\17\u0106\n\17\3\20\3\20\7\20\u010a\n\20\f\20\16\20\u010d")
        buf.write(u"\13\20\3\21\3\21\5\21\u0111\n\21\3\22\3\22\3\22\5\22")
        buf.write(u"\u0116\n\22\3\23\3\23\3\23\3\23\5\23\u011c\n\23\3\24")
        buf.write(u"\3\24\3\24\3\24\3\24\3\24\5\24\u0124\n\24\3\24\3\24\3")
        buf.write(u"\25\5\25\u0129\n\25\3\25\5\25\u012c\n\25\3\25\3\25\3")
        buf.write(u"\25\7\25\u0131\n\25\f\25\16\25\u0134\13\25\3\25\3\25")
        buf.write(u"\3\25\3\25\5\25\u013a\n\25\3\25\3\25\5\25\u013e\n\25")
        buf.write(u"\3\25\3\25\3\25\3\25\5\25\u0144\n\25\3\25\7\25\u0147")
        buf.write(u"\n\25\f\25\16\25\u014a\13\25\3\26\3\26\3\26\3\26\3\26")
        buf.write(u"\3\26\3\26\5\26\u0153\n\26\3\27\3\27\3\30\3\30\3\31\3")
        buf.write(u"\31\5\31\u015b\n\31\3\32\3\32\7\32\u015f\n\32\f\32\16")
        buf.write(u"\32\u0162\13\32\3\32\5\32\u0165\n\32\3\32\3\32\3\33\3")
        buf.write(u"\33\3\33\3\33\3\33\3\34\3\34\3\34\3\34\3\34\3\35\3\35")
        buf.write(u"\3\35\3\35\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\5")
        buf.write(u"\36\u017f\n\36\3\36\3\36\3\36\3\36\3\36\3\37\3\37\3\37")
        buf.write(u"\3\37\3\37\3\37\3 \3 \3 \7 \u018f\n \f \16 \u0192\13")
        buf.write(u" \3 \3 \3!\3!\3!\3!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\7")
        buf.write(u"\"\u01a2\n\"\f\"\16\"\u01a5\13\"\3\"\3\"\3#\3#\3#\3#")
        buf.write(u"\3#\3$\3$\3$\7$\u01b1\n$\f$\16$\u01b4\13$\3$\3$\3%\3")
        buf.write(u"%\3%\3%\3%\3&\3&\3&\3&\7&\u01c1\n&\f&\16&\u01c4\13&\3")
        buf.write(u"&\3&\3\'\3\'\3\'\3\'\3\'\3(\3(\3(\3(\3(\3(\7(\u01d3\n")
        buf.write(u"(\f(\16(\u01d6\13(\3(\3(\3)\3)\3)\3)\7)\u01de\n)\f)\16")
        buf.write(u")\u01e1\13)\3)\3)\3*\3*\3*\3*\5*\u01e9\n*\3*\5*\u01ec")
        buf.write(u"\n*\3*\3*\7*\u01f0\n*\f*\16*\u01f3\13*\3*\3*\5*\u01f7")
        buf.write(u"\n*\3+\3+\5+\u01fb\n+\3,\3,\3,\3,\5,\u0201\n,\3-\3-\3")
        buf.write(u"-\3-\3-\3-\7-\u0209\n-\f-\16-\u020c\13-\5-\u020e\n-\3")
        buf.write(u"-\3-\5-\u0212\n-\3-\3-\3-\3-\3.\3.\3.\3.\2\4\4\b/\2\4")
        buf.write(u"\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64")
        buf.write(u"\668:<>@BDFHJLNPRTVXZ\2\5\4\2\62\62JJ\3\2XY\3\2\37\"")
        buf.write(u"\2\u0256\2b\3\2\2\2\4m\3\2\2\2\6~\3\2\2\2\b\u008d\3\2")
        buf.write(u"\2\2\n\u00bf\3\2\2\2\f\u00c4\3\2\2\2\16\u00cb\3\2\2\2")
        buf.write(u"\20\u00d4\3\2\2\2\22\u00d8\3\2\2\2\24\u00da\3\2\2\2\26")
        buf.write(u"\u00e1\3\2\2\2\30\u00f0\3\2\2\2\32\u00fa\3\2\2\2\34\u0100")
        buf.write(u"\3\2\2\2\36\u010b\3\2\2\2 \u0110\3\2\2\2\"\u0115\3\2")
        buf.write(u"\2\2$\u011b\3\2\2\2&\u011d\3\2\2\2(\u0128\3\2\2\2*\u0152")
        buf.write(u"\3\2\2\2,\u0154\3\2\2\2.\u0156\3\2\2\2\60\u0158\3\2\2")
        buf.write(u"\2\62\u015c\3\2\2\2\64\u0168\3\2\2\2\66\u016d\3\2\2\2")
        buf.write(u"8\u0172\3\2\2\2:\u0176\3\2\2\2<\u0185\3\2\2\2>\u0190")
        buf.write(u"\3\2\2\2@\u0195\3\2\2\2B\u0199\3\2\2\2D\u01a8\3\2\2\2")
        buf.write(u"F\u01b2\3\2\2\2H\u01b7\3\2\2\2J\u01bc\3\2\2\2L\u01c7")
        buf.write(u"\3\2\2\2N\u01cc\3\2\2\2P\u01d9\3\2\2\2R\u01e4\3\2\2\2")
        buf.write(u"T\u01fa\3\2\2\2V\u01fc\3\2\2\2X\u0202\3\2\2\2Z\u0217")
        buf.write(u"\3\2\2\2\\c\7\t\2\2]c\7\n\2\2^c\7\13\2\2_c\7\f\2\2`c")
        buf.write(u"\7\r\2\2ac\5\4\3\2b\\\3\2\2\2b]\3\2\2\2b^\3\2\2\2b_\3")
        buf.write(u"\2\2\2b`\3\2\2\2ba\3\2\2\2c\3\3\2\2\2de\b\3\1\2ef\7\60")
        buf.write(u"\2\2fg\5\4\3\2gh\7\61\2\2hn\3\2\2\2ij\7X\2\2jk\7N\2\2")
        buf.write(u"kn\5\4\3\4ln\7W\2\2md\3\2\2\2mi\3\2\2\2ml\3\2\2\2nz\3")
        buf.write(u"\2\2\2or\f\5\2\2ps\7L\2\2qs\7N\2\2rp\3\2\2\2rq\3\2\2")
        buf.write(u"\2st\3\2\2\2ty\5\4\3\6uv\f\6\2\2vw\7M\2\2wy\5\6\4\2x")
        buf.write(u"o\3\2\2\2xu\3\2\2\2y|\3\2\2\2zx\3\2\2\2z{\3\2\2\2{\5")
        buf.write(u"\3\2\2\2|z\3\2\2\2}\177\t\2\2\2~}\3\2\2\2~\177\3\2\2")
        buf.write(u"\2\177\u0080\3\2\2\2\u0080\u0081\7X\2\2\u0081\7\3\2\2")
        buf.write(u"\2\u0082\u0083\b\5\1\2\u0083\u0084\7\60\2\2\u0084\u0085")
        buf.write(u"\5\b\5\2\u0085\u0086\7\61\2\2\u0086\u008e\3\2\2\2\u0087")
        buf.write(u"\u0088\5\f\7\2\u0088\u0089\5\b\5\13\u0089\u008e\3\2\2")
        buf.write(u"\2\u008a\u008b\7\32\2\2\u008b\u008e\5\b\5\6\u008c\u008e")
        buf.write(u"\5\n\6\2\u008d\u0082\3\2\2\2\u008d\u0087\3\2\2\2\u008d")
        buf.write(u"\u008a\3\2\2\2\u008d\u008c\3\2\2\2\u008e\u00b3\3\2\2")
        buf.write(u"\2\u008f\u0090\f\f\2\2\u0090\u0091\7M\2\2\u0091\u00b2")
        buf.write(u"\5\b\5\f\u0092\u0096\f\n\2\2\u0093\u0097\7L\2\2\u0094")
        buf.write(u"\u0097\7N\2\2\u0095\u0097\7O\2\2\u0096\u0093\3\2\2\2")
        buf.write(u"\u0096\u0094\3\2\2\2\u0096\u0095\3\2\2\2\u0097\u0098")
        buf.write(u"\3\2\2\2\u0098\u00b2\5\b\5\13\u0099\u009c\f\t\2\2\u009a")
        buf.write(u"\u009d\7\62\2\2\u009b\u009d\7J\2\2\u009c\u009a\3\2\2")
        buf.write(u"\2\u009c\u009b\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u00b2")
        buf.write(u"\5\b\5\n\u009f\u00a0\f\b\2\2\u00a0\u00a1\5\16\b\2\u00a1")
        buf.write(u"\u00a2\5\b\5\t\u00a2\u00b2\3\2\2\2\u00a3\u00a4\f\7\2")
        buf.write(u"\2\u00a4\u00a5\5\20\t\2\u00a5\u00a6\5\b\5\b\u00a6\u00b2")
        buf.write(u"\3\2\2\2\u00a7\u00a8\f\5\2\2\u00a8\u00a9\5\22\n\2\u00a9")
        buf.write(u"\u00aa\5\b\5\6\u00aa\u00b2\3\2\2\2\u00ab\u00ac\f\4\2")
        buf.write(u"\2\u00ac\u00ad\7P\2\2\u00ad\u00ae\5\b\5\2\u00ae\u00af")
        buf.write(u"\7Q\2\2\u00af\u00b0\5\b\5\5\u00b0\u00b2\3\2\2\2\u00b1")
        buf.write(u"\u008f\3\2\2\2\u00b1\u0092\3\2\2\2\u00b1\u0099\3\2\2")
        buf.write(u"\2\u00b1\u009f\3\2\2\2\u00b1\u00a3\3\2\2\2\u00b1\u00a7")
        buf.write(u"\3\2\2\2\u00b1\u00ab\3\2\2\2\u00b2\u00b5\3\2\2\2\u00b3")
        buf.write(u"\u00b1\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\t\3\2\2\2\u00b5")
        buf.write(u"\u00b3\3\2\2\2\u00b6\u00c0\5\26\f\2\u00b7\u00c0\7U\2")
        buf.write(u"\2\u00b8\u00ba\t\3\2\2\u00b9\u00bb\5\24\13\2\u00ba\u00b9")
        buf.write(u"\3\2\2\2\u00ba\u00bb\3\2\2\2\u00bb\u00c0\3\2\2\2\u00bc")
        buf.write(u"\u00c0\7V\2\2\u00bd\u00c0\7\27\2\2\u00be\u00c0\5\24\13")
        buf.write(u"\2\u00bf\u00b6\3\2\2\2\u00bf\u00b7\3\2\2\2\u00bf\u00b8")
        buf.write(u"\3\2\2\2\u00bf\u00bc\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf")
        buf.write(u"\u00be\3\2\2\2\u00c0\13\3\2\2\2\u00c1\u00c5\7\62\2\2")
        buf.write(u"\u00c2\u00c5\7J\2\2\u00c3\u00c5\7\63\2\2\u00c4\u00c1")
        buf.write(u"\3\2\2\2\u00c4\u00c2\3\2\2\2\u00c4\u00c3\3\2\2\2\u00c5")
        buf.write(u"\r\3\2\2\2\u00c6\u00cc\7\66\2\2\u00c7\u00cc\7\65\2\2")
        buf.write(u"\u00c8\u00cc\7\64\2\2\u00c9\u00cc\7<\2\2\u00ca\u00cc")
        buf.write(u"\7=\2\2\u00cb\u00c6\3\2\2\2\u00cb\u00c7\3\2\2\2\u00cb")
        buf.write(u"\u00c8\3\2\2\2\u00cb\u00c9\3\2\2\2\u00cb\u00ca\3\2\2")
        buf.write(u"\2\u00cc\17\3\2\2\2\u00cd\u00d5\7>\2\2\u00ce\u00d5\7")
        buf.write(u"@\2\2\u00cf\u00d5\7E\2\2\u00d0\u00d5\7F\2\2\u00d1\u00d5")
        buf.write(u"\7G\2\2\u00d2\u00d5\7H\2\2\u00d3\u00d5\7?\2\2\u00d4\u00cd")
        buf.write(u"\3\2\2\2\u00d4\u00ce\3\2\2\2\u00d4\u00cf\3\2\2\2\u00d4")
        buf.write(u"\u00d0\3\2\2\2\u00d4\u00d1\3\2\2\2\u00d4\u00d2\3\2\2")
        buf.write(u"\2\u00d4\u00d3\3\2\2\2\u00d5\21\3\2\2\2\u00d6\u00d9\7")
        buf.write(u"\30\2\2\u00d7\u00d9\7\31\2\2\u00d8\u00d6\3\2\2\2\u00d8")
        buf.write(u"\u00d7\3\2\2\2\u00d9\23\3\2\2\2\u00da\u00de\7W\2\2\u00db")
        buf.write(u"\u00dd\7T\2\2\u00dc\u00db\3\2\2\2\u00dd\u00e0\3\2\2\2")
        buf.write(u"\u00de\u00dc\3\2\2\2\u00de\u00df\3\2\2\2\u00df\25\3\2")
        buf.write(u"\2\2\u00e0\u00de\3\2\2\2\u00e1\u00e2\7W\2\2\u00e2\u00eb")
        buf.write(u"\7\60\2\2\u00e3\u00e8\5\b\5\2\u00e4\u00e5\7I\2\2\u00e5")
        buf.write(u"\u00e7\5\b\5\2\u00e6\u00e4\3\2\2\2\u00e7\u00ea\3\2\2")
        buf.write(u"\2\u00e8\u00e6\3\2\2\2\u00e8\u00e9\3\2\2\2\u00e9\u00ec")
        buf.write(u"\3\2\2\2\u00ea\u00e8\3\2\2\2\u00eb\u00e3\3\2\2\2\u00eb")
        buf.write(u"\u00ec\3\2\2\2\u00ec\u00ed\3\2\2\2\u00ed\u00ee\7\61\2")
        buf.write(u"\2\u00ee\27\3\2\2\2\u00ef\u00f1\7\33\2\2\u00f0\u00ef")
        buf.write(u"\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2")
        buf.write(u"\u00f3\7\16\2\2\u00f3\u00f4\7W\2\2\u00f4\u00f5\5\2\2")
        buf.write(u"\2\u00f5\u00f6\7K\2\2\u00f6\u00f8\5\b\5\2\u00f7\u00f9")
        buf.write(u"\7S\2\2\u00f8\u00f7\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9")
        buf.write(u"\31\3\2\2\2\u00fa\u00fb\5\24\13\2\u00fb\u00fc\7K\2\2")
        buf.write(u"\u00fc\u00fe\5\b\5\2\u00fd\u00ff\7S\2\2\u00fe\u00fd\3")
        buf.write(u"\2\2\2\u00fe\u00ff\3\2\2\2\u00ff\33\3\2\2\2\u0100\u0101")
        buf.write(u"\7\34\2\2\u0101\u0102\5\24\13\2\u0102\u0103\7K\2\2\u0103")
        buf.write(u"\u0105\5\b\5\2\u0104\u0106\7S\2\2\u0105\u0104\3\2\2\2")
        buf.write(u"\u0105\u0106\3\2\2\2\u0106\35\3\2\2\2\u0107\u010a\5 ")
        buf.write(u"\21\2\u0108\u010a\7\5\2\2\u0109\u0107\3\2\2\2\u0109\u0108")
        buf.write(u"\3\2\2\2\u010a\u010d\3\2\2\2\u010b\u0109\3\2\2\2\u010b")
        buf.write(u"\u010c\3\2\2\2\u010c\37\3\2\2\2\u010d\u010b\3\2\2\2\u010e")
        buf.write(u"\u0111\5$\23\2\u010f\u0111\5\"\22\2\u0110\u010e\3\2\2")
        buf.write(u"\2\u0110\u010f\3\2\2\2\u0111!\3\2\2\2\u0112\u0116\5\62")
        buf.write(u"\32\2\u0113\u0116\5:\36\2\u0114\u0116\5<\37\2\u0115\u0112")
        buf.write(u"\3\2\2\2\u0115\u0113\3\2\2\2\u0115\u0114\3\2\2\2\u0116")
        buf.write(u"#\3\2\2\2\u0117\u011c\5&\24\2\u0118\u011c\5\26\f\2\u0119")
        buf.write(u"\u011c\5(\25\2\u011a\u011c\5\60\31\2\u011b\u0117\3\2")
        buf.write(u"\2\2\u011b\u0118\3\2\2\2\u011b\u0119\3\2\2\2\u011b\u011a")
        buf.write(u"\3\2\2\2\u011c%\3\2\2\2\u011d\u0123\5\24\13\2\u011e\u0124")
        buf.write(u"\7K\2\2\u011f\u0124\7A\2\2\u0120\u0124\7B\2\2\u0121\u0124")
        buf.write(u"\7C\2\2\u0122\u0124\7D\2\2\u0123\u011e\3\2\2\2\u0123")
        buf.write(u"\u011f\3\2\2\2\u0123\u0120\3\2\2\2\u0123\u0121\3\2\2")
        buf.write(u"\2\u0123\u0122\3\2\2\2\u0124\u0125\3\2\2\2\u0125\u0126")
        buf.write(u"\5\b\5\2\u0126\'\3\2\2\2\u0127\u0129\7\33\2\2\u0128\u0127")
        buf.write(u"\3\2\2\2\u0128\u0129\3\2\2\2\u0129\u012b\3\2\2\2\u012a")
        buf.write(u"\u012c\7\16\2\2\u012b\u012a\3\2\2\2\u012b\u012c\3\2\2")
        buf.write(u"\2\u012c\u012d\3\2\2\2\u012d\u0132\5\24\13\2\u012e\u012f")
        buf.write(u"\7I\2\2\u012f\u0131\5\24\13\2\u0130\u012e\3\2\2\2\u0131")
        buf.write(u"\u0134\3\2\2\2\u0132\u0130\3\2\2\2\u0132\u0133\3\2\2")
        buf.write(u"\2\u0133\u0135\3\2\2\2\u0134\u0132\3\2\2\2\u0135\u0139")
        buf.write(u"\5\2\2\2\u0136\u0137\7\67\2\2\u0137\u0138\7W\2\2\u0138")
        buf.write(u"\u013a\79\2\2\u0139\u0136\3\2\2\2\u0139\u013a\3\2\2\2")
        buf.write(u"\u013a\u013d\3\2\2\2\u013b\u013c\7K\2\2\u013c\u013e\5")
        buf.write(u"\b\5\2\u013d\u013b\3\2\2\2\u013d\u013e\3\2\2\2\u013e")
        buf.write(u"\u0143\3\2\2\2\u013f\u0140\7:\2\2\u0140\u0141\5\b\5\2")
        buf.write(u"\u0141\u0142\7;\2\2\u0142\u0144\3\2\2\2\u0143\u013f\3")
        buf.write(u"\2\2\2\u0143\u0144\3\2\2\2\u0144\u0148\3\2\2\2\u0145")
        buf.write(u"\u0147\5*\26\2\u0146\u0145\3\2\2\2\u0147\u014a\3\2\2")
        buf.write(u"\2\u0148\u0146\3\2\2\2\u0148\u0149\3\2\2\2\u0149)\3\2")
        buf.write(u"\2\2\u014a\u0148\3\2\2\2\u014b\u0153\7,\2\2\u014c\u0153")
        buf.write(u"\7-\2\2\u014d\u014e\7.\2\2\u014e\u014f\5,\27\2\u014f")
        buf.write(u"\u0150\7R\2\2\u0150\u0151\5.\30\2\u0151\u0153\3\2\2\2")
        buf.write(u"\u0152\u014b\3\2\2\2\u0152\u014c\3\2\2\2\u0152\u014d")
        buf.write(u"\3\2\2\2\u0153+\3\2\2\2\u0154\u0155\7W\2\2\u0155-\3\2")
        buf.write(u"\2\2\u0156\u0157\7W\2\2\u0157/\3\2\2\2\u0158\u015a\7")
        buf.write(u"\17\2\2\u0159\u015b\5\b\5\2\u015a\u0159\3\2\2\2\u015a")
        buf.write(u"\u015b\3\2\2\2\u015b\61\3\2\2\2\u015c\u0160\5\64\33\2")
        buf.write(u"\u015d\u015f\5\66\34\2\u015e\u015d\3\2\2\2\u015f\u0162")
        buf.write(u"\3\2\2\2\u0160\u015e\3\2\2\2\u0160\u0161\3\2\2\2\u0161")
        buf.write(u"\u0164\3\2\2\2\u0162\u0160\3\2\2\2\u0163\u0165\58\35")
        buf.write(u"\2\u0164\u0163\3\2\2\2\u0164\u0165\3\2\2\2\u0165\u0166")
        buf.write(u"\3\2\2\2\u0166\u0167\7\b\2\2\u0167\63\3\2\2\2\u0168\u0169")
        buf.write(u"\7\20\2\2\u0169\u016a\5\b\5\2\u016a\u016b\7Q\2\2\u016b")
        buf.write(u"\u016c\5\36\20\2\u016c\65\3\2\2\2\u016d\u016e\7\21\2")
        buf.write(u"\2\u016e\u016f\5\b\5\2\u016f\u0170\7Q\2\2\u0170\u0171")
        buf.write(u"\5\36\20\2\u0171\67\3\2\2\2\u0172\u0173\7\22\2\2\u0173")
        buf.write(u"\u0174\7Q\2\2\u0174\u0175\5\36\20\2\u01759\3\2\2\2\u0176")
        buf.write(u"\u0177\7\23\2\2\u0177\u0178\7W\2\2\u0178\u0179\7\25\2")
        buf.write(u"\2\u0179\u017a\5\b\5\2\u017a\u017b\7/\2\2\u017b\u017c")
        buf.write(u"\5\b\5\2\u017c\u017e\7\26\2\2\u017d\u017f\7J\2\2\u017e")
        buf.write(u"\u017d\3\2\2\2\u017e\u017f\3\2\2\2\u017f\u0180\3\2\2")
        buf.write(u"\2\u0180\u0181\t\3\2\2\u0181\u0182\7Q\2\2\u0182\u0183")
        buf.write(u"\5\36\20\2\u0183\u0184\7\b\2\2\u0184;\3\2\2\2\u0185\u0186")
        buf.write(u"\7\24\2\2\u0186\u0187\5\b\5\2\u0187\u0188\7Q\2\2\u0188")
        buf.write(u"\u0189\5\36\20\2\u0189\u018a\7\b\2\2\u018a=\3\2\2\2\u018b")
        buf.write(u"\u018f\5@!\2\u018c\u018f\5D#\2\u018d\u018f\7\5\2\2\u018e")
        buf.write(u"\u018b\3\2\2\2\u018e\u018c\3\2\2\2\u018e\u018d\3\2\2")
        buf.write(u"\2\u018f\u0192\3\2\2\2\u0190\u018e\3\2\2\2\u0190\u0191")
        buf.write(u"\3\2\2\2\u0191\u0193\3\2\2\2\u0192\u0190\3\2\2\2\u0193")
        buf.write(u"\u0194\7\2\2\3\u0194?\3\2\2\2\u0195\u0196\7\35\2\2\u0196")
        buf.write(u"\u0197\7W\2\2\u0197\u0198\5B\"\2\u0198A\3\2\2\2\u0199")
        buf.write(u"\u01a3\7Q\2\2\u019a\u01a2\7\5\2\2\u019b\u01a2\5J&\2\u019c")
        buf.write(u"\u01a2\5N(\2\u019d\u01a2\5P)\2\u019e\u01a2\5V,\2\u019f")
        buf.write(u"\u01a2\5L\'\2\u01a0\u01a2\5X-\2\u01a1\u019a\3\2\2\2\u01a1")
        buf.write(u"\u019b\3\2\2\2\u01a1\u019c\3\2\2\2\u01a1\u019d\3\2\2")
        buf.write(u"\2\u01a1\u019e\3\2\2\2\u01a1\u019f\3\2\2\2\u01a1\u01a0")
        buf.write(u"\3\2\2\2\u01a2\u01a5\3\2\2\2\u01a3\u01a1\3\2\2\2\u01a3")
        buf.write(u"\u01a4\3\2\2\2\u01a4\u01a6\3\2\2\2\u01a5\u01a3\3\2\2")
        buf.write(u"\2\u01a6\u01a7\7\b\2\2\u01a7C\3\2\2\2\u01a8\u01a9\7\36")
        buf.write(u"\2\2\u01a9\u01aa\7W\2\2\u01aa\u01ab\7Q\2\2\u01ab\u01ac")
        buf.write(u"\5F$\2\u01acE\3\2\2\2\u01ad\u01b1\7\5\2\2\u01ae\u01b1")
        buf.write(u"\5J&\2\u01af\u01b1\5H%\2\u01b0\u01ad\3\2\2\2\u01b0\u01ae")
        buf.write(u"\3\2\2\2\u01b0\u01af\3\2\2\2\u01b1\u01b4\3\2\2\2\u01b2")
        buf.write(u"\u01b0\3\2\2\2\u01b2\u01b3\3\2\2\2\u01b3\u01b5\3\2\2")
        buf.write(u"\2\u01b4\u01b2\3\2\2\2\u01b5\u01b6\7\b\2\2\u01b6G\3\2")
        buf.write(u"\2\2\u01b7\u01b8\7\'\2\2\u01b8\u01b9\7Q\2\2\u01b9\u01ba")
        buf.write(u"\5\36\20\2\u01ba\u01bb\7\b\2\2\u01bbI\3\2\2\2\u01bc\u01bd")
        buf.write(u"\t\4\2\2\u01bd\u01c2\7Q\2\2\u01be\u01c1\5(\25\2\u01bf")
        buf.write(u"\u01c1\7\5\2\2\u01c0\u01be\3\2\2\2\u01c0\u01bf\3\2\2")
        buf.write(u"\2\u01c1\u01c4\3\2\2\2\u01c2\u01c0\3\2\2\2\u01c2\u01c3")
        buf.write(u"\3\2\2\2\u01c3\u01c5\3\2\2\2\u01c4\u01c2\3\2\2\2\u01c5")
        buf.write(u"\u01c6\7\b\2\2\u01c6K\3\2\2\2\u01c7\u01c8\7#\2\2\u01c8")
        buf.write(u"\u01c9\7Q\2\2\u01c9\u01ca\5\36\20\2\u01ca\u01cb\7\b\2")
        buf.write(u"\2\u01cbM\3\2\2\2\u01cc\u01cd\7$\2\2\u01cd\u01d4\7Q\2")
        buf.write(u"\2\u01ce\u01d3\5\30\r\2\u01cf\u01d3\5\32\16\2\u01d0\u01d3")
        buf.write(u"\5\34\17\2\u01d1\u01d3\7\5\2\2\u01d2\u01ce\3\2\2\2\u01d2")
        buf.write(u"\u01cf\3\2\2\2\u01d2\u01d0\3\2\2\2\u01d2\u01d1\3\2\2")
        buf.write(u"\2\u01d3\u01d6\3\2\2\2\u01d4\u01d2\3\2\2\2\u01d4\u01d5")
        buf.write(u"\3\2\2\2\u01d5\u01d7\3\2\2\2\u01d6\u01d4\3\2\2\2\u01d7")
        buf.write(u"\u01d8\7\b\2\2\u01d8O\3\2\2\2\u01d9\u01da\7%\2\2\u01da")
        buf.write(u"\u01df\7Q\2\2\u01db\u01de\5R*\2\u01dc\u01de\7\5\2\2\u01dd")
        buf.write(u"\u01db\3\2\2\2\u01dd\u01dc\3\2\2\2\u01de\u01e1\3\2\2")
        buf.write(u"\2\u01df\u01dd\3\2\2\2\u01df\u01e0\3\2\2\2\u01e0\u01e2")
        buf.write(u"\3\2\2\2\u01e1\u01df\3\2\2\2\u01e2\u01e3\7\b\2\2\u01e3")
        buf.write(u"Q\3\2\2\2\u01e4\u01e8\7W\2\2\u01e5\u01e6\7\67\2\2\u01e6")
        buf.write(u"\u01e7\7W\2\2\u01e7\u01e9\79\2\2\u01e8\u01e5\3\2\2\2")
        buf.write(u"\u01e8\u01e9\3\2\2\2\u01e9\u01eb\3\2\2\2\u01ea\u01ec")
        buf.write(u"\5\2\2\2\u01eb\u01ea\3\2\2\2\u01eb\u01ec\3\2\2\2\u01ec")
        buf.write(u"\u01ed\3\2\2\2\u01ed\u01f1\78\2\2\u01ee\u01f0\5T+\2\u01ef")
        buf.write(u"\u01ee\3\2\2\2\u01f0\u01f3\3\2\2\2\u01f1\u01ef\3\2\2")
        buf.write(u"\2\u01f1\u01f2\3\2\2\2\u01f2\u01f6\3\2\2\2\u01f3\u01f1")
        buf.write(u"\3\2\2\2\u01f4\u01f7\7(\2\2\u01f5\u01f7\7)\2\2\u01f6")
        buf.write(u"\u01f4\3\2\2\2\u01f6\u01f5\3\2\2\2\u01f7S\3\2\2\2\u01f8")
        buf.write(u"\u01fb\7*\2\2\u01f9\u01fb\7+\2\2\u01fa\u01f8\3\2\2\2")
        buf.write(u"\u01fa\u01f9\3\2\2\2\u01fbU\3\2\2\2\u01fc\u01fd\7&\2")
        buf.write(u"\2\u01fd\u0200\7Q\2\2\u01fe\u0201\7)\2\2\u01ff\u0201")
        buf.write(u"\7(\2\2\u0200\u01fe\3\2\2\2\u0200\u01ff\3\2\2\2\u0201")
        buf.write(u"W\3\2\2\2\u0202\u0203\7\16\2\2\u0203\u0204\7W\2\2\u0204")
        buf.write(u"\u020d\7\60\2\2\u0205\u020a\5Z.\2\u0206\u0207\7I\2\2")
        buf.write(u"\u0207\u0209\5Z.\2\u0208\u0206\3\2\2\2\u0209\u020c\3")
        buf.write(u"\2\2\2\u020a\u0208\3\2\2\2\u020a\u020b\3\2\2\2\u020b")
        buf.write(u"\u020e\3\2\2\2\u020c\u020a\3\2\2\2\u020d\u0205\3\2\2")
        buf.write(u"\2\u020d\u020e\3\2\2\2\u020e\u020f\3\2\2\2\u020f\u0211")
        buf.write(u"\7\61\2\2\u0210\u0212\5\2\2\2\u0211\u0210\3\2\2\2\u0211")
        buf.write(u"\u0212\3\2\2\2\u0212\u0213\3\2\2\2\u0213\u0214\7Q\2\2")
        buf.write(u"\u0214\u0215\5\36\20\2\u0215\u0216\7\b\2\2\u0216Y\3\2")
        buf.write(u"\2\2\u0217\u0218\7W\2\2\u0218\u0219\5\2\2\2\u0219[\3")
        buf.write(u"\2\2\2Abmrxz~\u008d\u0096\u009c\u00b1\u00b3\u00ba\u00bf")
        buf.write(u"\u00c4\u00cb\u00d4\u00d8\u00de\u00e8\u00eb\u00f0\u00f8")
        buf.write(u"\u00fe\u0105\u0109\u010b\u0110\u0115\u011b\u0123\u0128")
        buf.write(u"\u012b\u0132\u0139\u013d\u0143\u0148\u0152\u015a\u0160")
        buf.write(u"\u0164\u017e\u018e\u0190\u01a1\u01a3\u01b0\u01b2\u01c0")
        buf.write(u"\u01c2\u01d2\u01d4\u01dd\u01df\u01e8\u01eb\u01f1\u01f6")
        buf.write(u"\u01fa\u0200\u020a\u020d\u0211")
>>>>>>> origin/synapses-feature
        return buf.getvalue()


class PyNestMLParser ( Parser ):

    grammarFileName = "PyNestMLParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"'end'", u"'integer'", 
                     u"'real'", u"'string'", u"'boolean'", u"'void'", u"'function'", 
<<<<<<< HEAD
                     u"'inline'", u"'return'", u"'if'", u"'elif'", u"'else'", 
                     u"'for'", u"'while'", u"'in'", u"'step'", u"'inf'", 
                     u"'and'", u"'or'", u"'not'", u"'recordable'", u"'shape'", 
                     u"'neuron'", u"'synapse'", u"'state'", u"'parameters'", 
                     u"'internals'", u"'initial_values'", u"'update'", u"'equations'", 
                     u"'input'", u"'output'", u"'preReceive'", u"'postReceive'", 
                     u"'current'", u"'spike'", u"'inhibitory'", u"'excitatory'", 
                     u"'@homogeneous'", u"'@heterogeneous'", u"'@'", u"'...'", 
                     u"'('", u"')'", u"'+'", u"'~'", u"'|'", u"'^'", u"'&'", 
                     u"'['", u"'<-'", u"']'", u"'[['", u"']]'", u"'<<'", 
                     u"'>>'", u"'<'", u"'>'", u"'<='", u"'+='", u"'-='", 
                     u"'*='", u"'/='", u"'=='", u"'!='", u"'<>'", u"'>='", 
                     u"','", u"'-'", u"'='", u"'*'", u"'**'", u"'/'", u"'%'", 
                     u"'?'", u"':'", u"'::'", u"';'", u"'''" ]
=======
                     u"'return'", u"'if'", u"'elif'", u"'else'", u"'for'", 
                     u"'while'", u"'in'", u"'step'", u"'inf'", u"'and'", 
                     u"'or'", u"'not'", u"'recordable'", u"'shape'", u"'neuron'", 
                     u"'synapse'", u"'state'", u"'parameters'", u"'internals'", 
                     u"'initial_values'", u"'update'", u"'equations'", u"'input'", 
                     u"'output'", u"'preReceive'", u"'current'", u"'spike'", 
                     u"'inhibitory'", u"'excitatory'", u"'@homogeneous'", 
                     u"'@heterogeneous'", u"'@'", u"'...'", u"'('", u"')'", 
                     u"'+'", u"'~'", u"'|'", u"'^'", u"'&'", u"'['", u"'<-'", 
                     u"']'", u"'[['", u"']]'", u"'<<'", u"'>>'", u"'<'", 
                     u"'>'", u"'<='", u"'+='", u"'-='", u"'*='", u"'/='", 
                     u"'=='", u"'!='", u"'<>'", u"'>='", u"','", u"'-'", 
                     u"'='", u"'*'", u"'**'", u"'/'", u"'%'", u"'?'", u"':'", 
                     u"'::'", u"';'", u"'''" ]
>>>>>>> origin/synapses-feature

    symbolicNames = [ u"<INVALID>", u"SL_COMMENT", u"ML_COMMENT", u"NEWLINE", 
                      u"WS", u"LINE_ESCAPE", u"END_KEYWORD", u"INTEGER_KEYWORD", 
                      u"REAL_KEYWORD", u"STRING_KEYWORD", u"BOOLEAN_KEYWORD", 
                      u"VOID_KEYWORD", u"FUNCTION_KEYWORD", u"INLINE_KEYWORD", 
                      u"RETURN_KEYWORD", u"IF_KEYWORD", u"ELIF_KEYWORD", 
                      u"ELSE_KEYWORD", u"FOR_KEYWORD", u"WHILE_KEYWORD", 
                      u"IN_KEYWORD", u"STEP_KEYWORD", u"INF_KEYWORD", u"AND_KEYWORD", 
                      u"OR_KEYWORD", u"NOT_KEYWORD", u"RECORDABLE_KEYWORD", 
                      u"SHAPE_KEYWORD", u"NEURON_KEYWORD", u"SYNAPSE_KEYWORD", 
                      u"STATE_KEYWORD", u"PARAMETERS_KEYWORD", u"INTERNALS_KEYWORD", 
                      u"INITIAL_VALUES_KEYWORD", u"UPDATE_KEYWORD", u"EQUATIONS_KEYWORD", 
                      u"INPUT_KEYWORD", u"OUTPUT_KEYWORD", u"PRE_RECEIVE_KEYWORD", 
                      u"POST_RECEIVE_KEYWORD", u"CURRENT_KEYWORD", u"SPIKE_KEYWORD", 
                      u"INHIBITORY_KEYWORD", u"EXCITATORY_KEYWORD", u"DECORATOR_HOMOGENEOUS", 
                      u"DECORATOR_HETEROGENEOUS", u"AT", u"ELLIPSIS", u"LEFT_PAREN", 
                      u"RIGHT_PAREN", u"PLUS", u"TILDE", u"PIPE", u"CARET", 
                      u"AMPERSAND", u"LEFT_SQUARE_BRACKET", u"LEFT_ANGLE_MINUS", 
                      u"RIGHT_SQUARE_BRACKET", u"LEFT_LEFT_SQUARE", u"RIGHT_RIGHT_SQUARE", 
                      u"LEFT_LEFT_ANGLE", u"RIGHT_RIGHT_ANGLE", u"LEFT_ANGLE", 
                      u"RIGHT_ANGLE", u"LEFT_ANGLE_EQUALS", u"PLUS_EQUALS", 
                      u"MINUS_EQUALS", u"STAR_EQUALS", u"FORWARD_SLASH_EQUALS", 
                      u"EQUALS_EQUALS", u"EXCLAMATION_EQUALS", u"LEFT_ANGLE_RIGHT_ANGLE", 
                      u"RIGHT_ANGLE_EQUALS", u"COMMA", u"MINUS", u"EQUALS", 
                      u"STAR", u"STAR_STAR", u"FORWARD_SLASH", u"PERCENT", 
                      u"QUESTION", u"COLON", u"DOUBLE_COLON", u"SEMICOLON", 
                      u"DIFFERENTIAL_ORDER", u"BOOLEAN_LITERAL", u"STRING_LITERAL", 
                      u"NAME", u"UNSIGNED_INTEGER", u"FLOAT" ]

    RULE_dataType = 0
    RULE_unitType = 1
    RULE_unitTypeExponent = 2
    RULE_expression = 3
    RULE_simpleExpression = 4
    RULE_unaryOperator = 5
    RULE_bitOperator = 6
    RULE_comparisonOperator = 7
    RULE_logicalOperator = 8
    RULE_variable = 9
    RULE_functionCall = 10
    RULE_inlineExpression = 11
    RULE_odeEquation = 12
    RULE_odeShape = 13
    RULE_block = 14
    RULE_stmt = 15
    RULE_compoundStmt = 16
    RULE_smallStmt = 17
    RULE_assignment = 18
    RULE_declaration = 19
    RULE_anyDecorator = 20
    RULE_namespaceDecoratorNamespace = 21
    RULE_namespaceDecoratorName = 22
    RULE_returnStmt = 23
    RULE_ifStmt = 24
    RULE_ifClause = 25
    RULE_elifClause = 26
    RULE_elseClause = 27
    RULE_forStmt = 28
    RULE_whileStmt = 29
    RULE_nestMLCompilationUnit = 30
    RULE_neuron = 31
    RULE_body = 32
    RULE_synapse = 33
    RULE_synapseBody = 34
    RULE_preReceiveBlock = 35
<<<<<<< HEAD
    RULE_postReceiveBlock = 36
    RULE_blockWithVariables = 37
    RULE_updateBlock = 38
    RULE_equationsBlock = 39
    RULE_inputBlock = 40
    RULE_inputPort = 41
    RULE_inputQualifier = 42
    RULE_outputBlock = 43
    RULE_function = 44
    RULE_parameter = 45
=======
    RULE_blockWithVariables = 36
    RULE_updateBlock = 37
    RULE_equationsBlock = 38
    RULE_inputBlock = 39
    RULE_inputLine = 40
    RULE_inputType = 41
    RULE_outputBlock = 42
    RULE_function = 43
    RULE_parameter = 44
>>>>>>> origin/synapses-feature

    ruleNames =  [ u"dataType", u"unitType", u"unitTypeExponent", u"expression", 
                   u"simpleExpression", u"unaryOperator", u"bitOperator", 
                   u"comparisonOperator", u"logicalOperator", u"variable", 
<<<<<<< HEAD
                   u"functionCall", u"inlineExpression", u"odeEquation", 
                   u"odeShape", u"block", u"stmt", u"compoundStmt", u"smallStmt", 
                   u"assignment", u"declaration", u"anyDecorator", u"namespaceDecoratorNamespace", 
                   u"namespaceDecoratorName", u"returnStmt", u"ifStmt", 
                   u"ifClause", u"elifClause", u"elseClause", u"forStmt", 
                   u"whileStmt", u"nestMLCompilationUnit", u"neuron", u"body", 
                   u"synapse", u"synapseBody", u"preReceiveBlock", u"postReceiveBlock", 
                   u"blockWithVariables", u"updateBlock", u"equationsBlock", 
                   u"inputBlock", u"inputPort", u"inputQualifier", u"outputBlock", 
                   u"function", u"parameter" ]
=======
                   u"functionCall", u"odeFunction", u"odeEquation", u"odeShape", 
                   u"block", u"stmt", u"compoundStmt", u"smallStmt", u"assignment", 
                   u"declaration", u"anyDecorator", u"namespaceDecoratorNamespace", 
                   u"namespaceDecoratorName", u"returnStmt", u"ifStmt", 
                   u"ifClause", u"elifClause", u"elseClause", u"forStmt", 
                   u"whileStmt", u"nestMLCompilationUnit", u"neuron", u"body", 
                   u"synapse", u"synapseBody", u"preReceiveBlock", u"blockWithVariables", 
                   u"updateBlock", u"equationsBlock", u"inputBlock", u"inputLine", 
                   u"inputType", u"outputBlock", u"function", u"parameter" ]
>>>>>>> origin/synapses-feature

    EOF = Token.EOF
    SL_COMMENT=1
    ML_COMMENT=2
    NEWLINE=3
    WS=4
    LINE_ESCAPE=5
    END_KEYWORD=6
    INTEGER_KEYWORD=7
    REAL_KEYWORD=8
    STRING_KEYWORD=9
    BOOLEAN_KEYWORD=10
    VOID_KEYWORD=11
    FUNCTION_KEYWORD=12
<<<<<<< HEAD
    INLINE_KEYWORD=13
    RETURN_KEYWORD=14
    IF_KEYWORD=15
    ELIF_KEYWORD=16
    ELSE_KEYWORD=17
    FOR_KEYWORD=18
    WHILE_KEYWORD=19
    IN_KEYWORD=20
    STEP_KEYWORD=21
    INF_KEYWORD=22
    AND_KEYWORD=23
    OR_KEYWORD=24
    NOT_KEYWORD=25
    RECORDABLE_KEYWORD=26
    SHAPE_KEYWORD=27
    NEURON_KEYWORD=28
    SYNAPSE_KEYWORD=29
    STATE_KEYWORD=30
    PARAMETERS_KEYWORD=31
    INTERNALS_KEYWORD=32
    INITIAL_VALUES_KEYWORD=33
    UPDATE_KEYWORD=34
    EQUATIONS_KEYWORD=35
    INPUT_KEYWORD=36
    OUTPUT_KEYWORD=37
    PRE_RECEIVE_KEYWORD=38
    POST_RECEIVE_KEYWORD=39
    CURRENT_KEYWORD=40
    SPIKE_KEYWORD=41
    INHIBITORY_KEYWORD=42
    EXCITATORY_KEYWORD=43
    DECORATOR_HOMOGENEOUS=44
    DECORATOR_HETEROGENEOUS=45
    AT=46
    ELLIPSIS=47
    LEFT_PAREN=48
    RIGHT_PAREN=49
    PLUS=50
    TILDE=51
    PIPE=52
    CARET=53
    AMPERSAND=54
    LEFT_SQUARE_BRACKET=55
    LEFT_ANGLE_MINUS=56
    RIGHT_SQUARE_BRACKET=57
    LEFT_LEFT_SQUARE=58
    RIGHT_RIGHT_SQUARE=59
    LEFT_LEFT_ANGLE=60
    RIGHT_RIGHT_ANGLE=61
    LEFT_ANGLE=62
    RIGHT_ANGLE=63
    LEFT_ANGLE_EQUALS=64
    PLUS_EQUALS=65
    MINUS_EQUALS=66
    STAR_EQUALS=67
    FORWARD_SLASH_EQUALS=68
    EQUALS_EQUALS=69
    EXCLAMATION_EQUALS=70
    LEFT_ANGLE_RIGHT_ANGLE=71
    RIGHT_ANGLE_EQUALS=72
    COMMA=73
    MINUS=74
    EQUALS=75
    STAR=76
    STAR_STAR=77
    FORWARD_SLASH=78
    PERCENT=79
    QUESTION=80
    COLON=81
    DOUBLE_COLON=82
    SEMICOLON=83
    DIFFERENTIAL_ORDER=84
    BOOLEAN_LITERAL=85
    STRING_LITERAL=86
    NAME=87
    UNSIGNED_INTEGER=88
    FLOAT=89
=======
    RETURN_KEYWORD=13
    IF_KEYWORD=14
    ELIF_KEYWORD=15
    ELSE_KEYWORD=16
    FOR_KEYWORD=17
    WHILE_KEYWORD=18
    IN_KEYWORD=19
    STEP_KEYWORD=20
    INF_KEYWORD=21
    AND_KEYWORD=22
    OR_KEYWORD=23
    NOT_KEYWORD=24
    RECORDABLE_KEYWORD=25
    SHAPE_KEYWORD=26
    NEURON_KEYWORD=27
    SYNAPSE_KEYWORD=28
    STATE_KEYWORD=29
    PARAMETERS_KEYWORD=30
    INTERNALS_KEYWORD=31
    INITIAL_VALUES_KEYWORD=32
    UPDATE_KEYWORD=33
    EQUATIONS_KEYWORD=34
    INPUT_KEYWORD=35
    OUTPUT_KEYWORD=36
    PRE_RECEIVE_KEYWORD=37
    CURRENT_KEYWORD=38
    SPIKE_KEYWORD=39
    INHIBITORY_KEYWORD=40
    EXCITATORY_KEYWORD=41
    DECORATOR_HOMOGENEOUS=42
    DECORATOR_HETEROGENEOUS=43
    AT=44
    ELLIPSIS=45
    LEFT_PAREN=46
    RIGHT_PAREN=47
    PLUS=48
    TILDE=49
    PIPE=50
    CARET=51
    AMPERSAND=52
    LEFT_SQUARE_BRACKET=53
    LEFT_ANGLE_MINUS=54
    RIGHT_SQUARE_BRACKET=55
    LEFT_LEFT_SQUARE=56
    RIGHT_RIGHT_SQUARE=57
    LEFT_LEFT_ANGLE=58
    RIGHT_RIGHT_ANGLE=59
    LEFT_ANGLE=60
    RIGHT_ANGLE=61
    LEFT_ANGLE_EQUALS=62
    PLUS_EQUALS=63
    MINUS_EQUALS=64
    STAR_EQUALS=65
    FORWARD_SLASH_EQUALS=66
    EQUALS_EQUALS=67
    EXCLAMATION_EQUALS=68
    LEFT_ANGLE_RIGHT_ANGLE=69
    RIGHT_ANGLE_EQUALS=70
    COMMA=71
    MINUS=72
    EQUALS=73
    STAR=74
    STAR_STAR=75
    FORWARD_SLASH=76
    PERCENT=77
    QUESTION=78
    COLON=79
    DOUBLE_COLON=80
    SEMICOLON=81
    DIFFERENTIAL_ORDER=82
    BOOLEAN_LITERAL=83
    STRING_LITERAL=84
    NAME=85
    UNSIGNED_INTEGER=86
    FLOAT=87
>>>>>>> origin/synapses-feature

    def __init__(self, input, output=sys.stdout):
        super(PyNestMLParser, self).__init__(input, output=output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class DataTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.DataTypeContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.isInt = None # Token
            self.isReal = None # Token
            self.isString = None # Token
            self.isBool = None # Token
            self.isVoid = None # Token
            self.unit = None # UnitTypeContext

        def INTEGER_KEYWORD(self):
            return self.getToken(PyNestMLParser.INTEGER_KEYWORD, 0)

        def REAL_KEYWORD(self):
            return self.getToken(PyNestMLParser.REAL_KEYWORD, 0)

        def STRING_KEYWORD(self):
            return self.getToken(PyNestMLParser.STRING_KEYWORD, 0)

        def BOOLEAN_KEYWORD(self):
            return self.getToken(PyNestMLParser.BOOLEAN_KEYWORD, 0)

        def VOID_KEYWORD(self):
            return self.getToken(PyNestMLParser.VOID_KEYWORD, 0)

        def unitType(self):
            return self.getTypedRuleContext(PyNestMLParser.UnitTypeContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_dataType

        def accept(self, visitor):
            if hasattr(visitor, "visitDataType"):
                return visitor.visitDataType(self)
            else:
                return visitor.visitChildren(self)




    def dataType(self):

        localctx = PyNestMLParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_dataType)
        try:
<<<<<<< HEAD
            self.state = 98
=======
            self.state = 96
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.INTEGER_KEYWORD]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 92
=======
                self.state = 90
>>>>>>> origin/synapses-feature
                localctx.isInt = self.match(PyNestMLParser.INTEGER_KEYWORD)
                pass
            elif token in [PyNestMLParser.REAL_KEYWORD]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 93
=======
                self.state = 91
>>>>>>> origin/synapses-feature
                localctx.isReal = self.match(PyNestMLParser.REAL_KEYWORD)
                pass
            elif token in [PyNestMLParser.STRING_KEYWORD]:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 94
=======
                self.state = 92
>>>>>>> origin/synapses-feature
                localctx.isString = self.match(PyNestMLParser.STRING_KEYWORD)
                pass
            elif token in [PyNestMLParser.BOOLEAN_KEYWORD]:
                self.enterOuterAlt(localctx, 4)
<<<<<<< HEAD
                self.state = 95
=======
                self.state = 93
>>>>>>> origin/synapses-feature
                localctx.isBool = self.match(PyNestMLParser.BOOLEAN_KEYWORD)
                pass
            elif token in [PyNestMLParser.VOID_KEYWORD]:
                self.enterOuterAlt(localctx, 5)
<<<<<<< HEAD
                self.state = 96
=======
                self.state = 94
>>>>>>> origin/synapses-feature
                localctx.isVoid = self.match(PyNestMLParser.VOID_KEYWORD)
                pass
            elif token in [PyNestMLParser.LEFT_PAREN, PyNestMLParser.NAME, PyNestMLParser.UNSIGNED_INTEGER]:
                self.enterOuterAlt(localctx, 6)
<<<<<<< HEAD
                self.state = 97
=======
                self.state = 95
>>>>>>> origin/synapses-feature
                localctx.unit = self.unitType(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitTypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.UnitTypeContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.base = None # UnitTypeContext
            self.left = None # UnitTypeContext
            self.leftParentheses = None # Token
            self.compoundUnit = None # UnitTypeContext
            self.rightParentheses = None # Token
            self.unitlessLiteral = None # Token
            self.divOp = None # Token
            self.right = None # UnitTypeContext
            self.unit = None # Token
            self.timesOp = None # Token
            self.powOp = None # Token
            self.exponent = None # UnitTypeExponentContext

        def LEFT_PAREN(self):
            return self.getToken(PyNestMLParser.LEFT_PAREN, 0)

        def unitType(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.UnitTypeContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.UnitTypeContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(PyNestMLParser.RIGHT_PAREN, 0)

        def UNSIGNED_INTEGER(self):
            return self.getToken(PyNestMLParser.UNSIGNED_INTEGER, 0)

        def FORWARD_SLASH(self):
            return self.getToken(PyNestMLParser.FORWARD_SLASH, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def STAR(self):
            return self.getToken(PyNestMLParser.STAR, 0)

        def STAR_STAR(self):
            return self.getToken(PyNestMLParser.STAR_STAR, 0)

        def unitTypeExponent(self):
            return self.getTypedRuleContext(PyNestMLParser.UnitTypeExponentContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_unitType

        def accept(self, visitor):
            if hasattr(visitor, "visitUnitType"):
                return visitor.visitUnitType(self)
            else:
                return visitor.visitChildren(self)



    def unitType(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PyNestMLParser.UnitTypeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_unitType, _p)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.LEFT_PAREN]:
                self.state = 101
                localctx.leftParentheses = self.match(PyNestMLParser.LEFT_PAREN)
                self.state = 102
                localctx.compoundUnit = self.unitType(0)
                self.state = 103
                localctx.rightParentheses = self.match(PyNestMLParser.RIGHT_PAREN)
                pass
            elif token in [PyNestMLParser.UNSIGNED_INTEGER]:
                self.state = 105
                localctx.unitlessLiteral = self.match(PyNestMLParser.UNSIGNED_INTEGER)
                self.state = 106
                localctx.divOp = self.match(PyNestMLParser.FORWARD_SLASH)
                self.state = 107
                localctx.right = self.unitType(2)
                pass
            elif token in [PyNestMLParser.NAME]:
                self.state = 108
=======
            self.state = 107
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.LEFT_PAREN]:
                self.state = 99
                localctx.leftParentheses = self.match(PyNestMLParser.LEFT_PAREN)
                self.state = 100
                localctx.compoundUnit = self.unitType(0)
                self.state = 101
                localctx.rightParentheses = self.match(PyNestMLParser.RIGHT_PAREN)
                pass
            elif token in [PyNestMLParser.UNSIGNED_INTEGER]:
                self.state = 103
                localctx.unitlessLiteral = self.match(PyNestMLParser.UNSIGNED_INTEGER)
                self.state = 104
                localctx.divOp = self.match(PyNestMLParser.FORWARD_SLASH)
                self.state = 105
                localctx.right = self.unitType(2)
                pass
            elif token in [PyNestMLParser.NAME]:
                self.state = 106
>>>>>>> origin/synapses-feature
                localctx.unit = self.match(PyNestMLParser.NAME)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
<<<<<<< HEAD
            self.state = 122
=======
            self.state = 120
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
<<<<<<< HEAD
                    self.state = 120
=======
                    self.state = 118
>>>>>>> origin/synapses-feature
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                    if la_ == 1:
                        localctx = PyNestMLParser.UnitTypeContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_unitType)
<<<<<<< HEAD
                        self.state = 111
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 114
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [PyNestMLParser.STAR]:
                            self.state = 112
                            localctx.timesOp = self.match(PyNestMLParser.STAR)
                            pass
                        elif token in [PyNestMLParser.FORWARD_SLASH]:
                            self.state = 113
=======
                        self.state = 109
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 112
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [PyNestMLParser.STAR]:
                            self.state = 110
                            localctx.timesOp = self.match(PyNestMLParser.STAR)
                            pass
                        elif token in [PyNestMLParser.FORWARD_SLASH]:
                            self.state = 111
>>>>>>> origin/synapses-feature
                            localctx.divOp = self.match(PyNestMLParser.FORWARD_SLASH)
                            pass
                        else:
                            raise NoViableAltException(self)

<<<<<<< HEAD
                        self.state = 116
=======
                        self.state = 114
>>>>>>> origin/synapses-feature
                        localctx.right = self.unitType(4)
                        pass

                    elif la_ == 2:
                        localctx = PyNestMLParser.UnitTypeContext(self, _parentctx, _parentState)
                        localctx.base = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_unitType)
<<<<<<< HEAD
                        self.state = 117
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 118
                        localctx.powOp = self.match(PyNestMLParser.STAR_STAR)
                        self.state = 119
=======
                        self.state = 115
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 116
                        localctx.powOp = self.match(PyNestMLParser.STAR_STAR)
                        self.state = 117
>>>>>>> origin/synapses-feature
                        localctx.exponent = self.unitTypeExponent()
                        pass

             
<<<<<<< HEAD
                self.state = 124
=======
                self.state = 122
>>>>>>> origin/synapses-feature
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class UnitTypeExponentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.UnitTypeExponentContext, self).__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INTEGER(self):
            return self.getToken(PyNestMLParser.UNSIGNED_INTEGER, 0)

        def PLUS(self):
            return self.getToken(PyNestMLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(PyNestMLParser.MINUS, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_unitTypeExponent

        def accept(self, visitor):
            if hasattr(visitor, "visitUnitTypeExponent"):
                return visitor.visitUnitTypeExponent(self)
            else:
                return visitor.visitChildren(self)




    def unitTypeExponent(self):

        localctx = PyNestMLParser.UnitTypeExponentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_unitTypeExponent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.PLUS or _la==PyNestMLParser.MINUS:
                self.state = 125
=======
            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.PLUS or _la==PyNestMLParser.MINUS:
                self.state = 123
>>>>>>> origin/synapses-feature
                _la = self._input.LA(1)
                if not(_la==PyNestMLParser.PLUS or _la==PyNestMLParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


<<<<<<< HEAD
            self.state = 128
=======
            self.state = 126
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.UNSIGNED_INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.left = None # ExpressionContext
            self.condition = None # ExpressionContext
            self.leftParentheses = None # Token
            self.term = None # ExpressionContext
            self.rightParentheses = None # Token
            self.logicalNot = None # Token
            self.powOp = None # Token
            self.right = None # ExpressionContext
            self.timesOp = None # Token
            self.divOp = None # Token
            self.moduloOp = None # Token
            self.plusOp = None # Token
            self.minusOp = None # Token
            self.ifTrue = None # ExpressionContext
            self.ifNot = None # ExpressionContext

        def LEFT_PAREN(self):
            return self.getToken(PyNestMLParser.LEFT_PAREN, 0)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(PyNestMLParser.RIGHT_PAREN, 0)

        def unaryOperator(self):
            return self.getTypedRuleContext(PyNestMLParser.UnaryOperatorContext,0)


        def NOT_KEYWORD(self):
            return self.getToken(PyNestMLParser.NOT_KEYWORD, 0)

        def simpleExpression(self):
            return self.getTypedRuleContext(PyNestMLParser.SimpleExpressionContext,0)


        def STAR_STAR(self):
            return self.getToken(PyNestMLParser.STAR_STAR, 0)

        def STAR(self):
            return self.getToken(PyNestMLParser.STAR, 0)

        def FORWARD_SLASH(self):
            return self.getToken(PyNestMLParser.FORWARD_SLASH, 0)

        def PERCENT(self):
            return self.getToken(PyNestMLParser.PERCENT, 0)

        def PLUS(self):
            return self.getToken(PyNestMLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(PyNestMLParser.MINUS, 0)

        def bitOperator(self):
            return self.getTypedRuleContext(PyNestMLParser.BitOperatorContext,0)


        def comparisonOperator(self):
            return self.getTypedRuleContext(PyNestMLParser.ComparisonOperatorContext,0)


        def logicalOperator(self):
            return self.getTypedRuleContext(PyNestMLParser.LogicalOperatorContext,0)


        def QUESTION(self):
            return self.getToken(PyNestMLParser.QUESTION, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_expression

        def accept(self, visitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = PyNestMLParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.LEFT_PAREN]:
                self.state = 131
                localctx.leftParentheses = self.match(PyNestMLParser.LEFT_PAREN)
                self.state = 132
                localctx.term = self.expression(0)
                self.state = 133
                localctx.rightParentheses = self.match(PyNestMLParser.RIGHT_PAREN)
                pass
            elif token in [PyNestMLParser.PLUS, PyNestMLParser.TILDE, PyNestMLParser.MINUS]:
                self.state = 135
                self.unaryOperator()
                self.state = 136
                localctx.term = self.expression(9)
                pass
            elif token in [PyNestMLParser.NOT_KEYWORD]:
                self.state = 138
                localctx.logicalNot = self.match(PyNestMLParser.NOT_KEYWORD)
                self.state = 139
                localctx.term = self.expression(4)
                pass
            elif token in [PyNestMLParser.INF_KEYWORD, PyNestMLParser.BOOLEAN_LITERAL, PyNestMLParser.STRING_LITERAL, PyNestMLParser.NAME, PyNestMLParser.UNSIGNED_INTEGER, PyNestMLParser.FLOAT]:
                self.state = 140
=======
            self.state = 139
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.LEFT_PAREN]:
                self.state = 129
                localctx.leftParentheses = self.match(PyNestMLParser.LEFT_PAREN)
                self.state = 130
                localctx.term = self.expression(0)
                self.state = 131
                localctx.rightParentheses = self.match(PyNestMLParser.RIGHT_PAREN)
                pass
            elif token in [PyNestMLParser.PLUS, PyNestMLParser.TILDE, PyNestMLParser.MINUS]:
                self.state = 133
                self.unaryOperator()
                self.state = 134
                localctx.term = self.expression(9)
                pass
            elif token in [PyNestMLParser.NOT_KEYWORD]:
                self.state = 136
                localctx.logicalNot = self.match(PyNestMLParser.NOT_KEYWORD)
                self.state = 137
                localctx.term = self.expression(4)
                pass
            elif token in [PyNestMLParser.INF_KEYWORD, PyNestMLParser.BOOLEAN_LITERAL, PyNestMLParser.STRING_LITERAL, PyNestMLParser.NAME, PyNestMLParser.UNSIGNED_INTEGER, PyNestMLParser.FLOAT]:
                self.state = 138
>>>>>>> origin/synapses-feature
                self.simpleExpression()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
<<<<<<< HEAD
            self.state = 179
=======
            self.state = 177
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
<<<<<<< HEAD
                    self.state = 177
=======
                    self.state = 175
>>>>>>> origin/synapses-feature
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
                    if la_ == 1:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 143
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 144
                        localctx.powOp = self.match(PyNestMLParser.STAR_STAR)
                        self.state = 145
=======
                        self.state = 141
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 142
                        localctx.powOp = self.match(PyNestMLParser.STAR_STAR)
                        self.state = 143
>>>>>>> origin/synapses-feature
                        localctx.right = self.expression(10)
                        pass

                    elif la_ == 2:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 146
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 150
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [PyNestMLParser.STAR]:
                            self.state = 147
                            localctx.timesOp = self.match(PyNestMLParser.STAR)
                            pass
                        elif token in [PyNestMLParser.FORWARD_SLASH]:
                            self.state = 148
                            localctx.divOp = self.match(PyNestMLParser.FORWARD_SLASH)
                            pass
                        elif token in [PyNestMLParser.PERCENT]:
                            self.state = 149
=======
                        self.state = 144
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 148
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [PyNestMLParser.STAR]:
                            self.state = 145
                            localctx.timesOp = self.match(PyNestMLParser.STAR)
                            pass
                        elif token in [PyNestMLParser.FORWARD_SLASH]:
                            self.state = 146
                            localctx.divOp = self.match(PyNestMLParser.FORWARD_SLASH)
                            pass
                        elif token in [PyNestMLParser.PERCENT]:
                            self.state = 147
>>>>>>> origin/synapses-feature
                            localctx.moduloOp = self.match(PyNestMLParser.PERCENT)
                            pass
                        else:
                            raise NoViableAltException(self)

<<<<<<< HEAD
                        self.state = 152
=======
                        self.state = 150
>>>>>>> origin/synapses-feature
                        localctx.right = self.expression(9)
                        pass

                    elif la_ == 3:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 153
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 156
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [PyNestMLParser.PLUS]:
                            self.state = 154
                            localctx.plusOp = self.match(PyNestMLParser.PLUS)
                            pass
                        elif token in [PyNestMLParser.MINUS]:
                            self.state = 155
=======
                        self.state = 151
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 154
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [PyNestMLParser.PLUS]:
                            self.state = 152
                            localctx.plusOp = self.match(PyNestMLParser.PLUS)
                            pass
                        elif token in [PyNestMLParser.MINUS]:
                            self.state = 153
>>>>>>> origin/synapses-feature
                            localctx.minusOp = self.match(PyNestMLParser.MINUS)
                            pass
                        else:
                            raise NoViableAltException(self)

<<<<<<< HEAD
                        self.state = 158
=======
                        self.state = 156
>>>>>>> origin/synapses-feature
                        localctx.right = self.expression(8)
                        pass

                    elif la_ == 4:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 159
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 160
                        self.bitOperator()
                        self.state = 161
=======
                        self.state = 157
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 158
                        self.bitOperator()
                        self.state = 159
>>>>>>> origin/synapses-feature
                        localctx.right = self.expression(7)
                        pass

                    elif la_ == 5:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 163
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 164
                        self.comparisonOperator()
                        self.state = 165
=======
                        self.state = 161
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 162
                        self.comparisonOperator()
                        self.state = 163
>>>>>>> origin/synapses-feature
                        localctx.right = self.expression(6)
                        pass

                    elif la_ == 6:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 167
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 168
                        self.logicalOperator()
                        self.state = 169
=======
                        self.state = 165
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 166
                        self.logicalOperator()
                        self.state = 167
>>>>>>> origin/synapses-feature
                        localctx.right = self.expression(4)
                        pass

                    elif la_ == 7:
                        localctx = PyNestMLParser.ExpressionContext(self, _parentctx, _parentState)
                        localctx.condition = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
<<<<<<< HEAD
                        self.state = 171
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 172
                        self.match(PyNestMLParser.QUESTION)
                        self.state = 173
                        localctx.ifTrue = self.expression(0)
                        self.state = 174
                        self.match(PyNestMLParser.COLON)
                        self.state = 175
=======
                        self.state = 169
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 170
                        self.match(PyNestMLParser.QUESTION)
                        self.state = 171
                        localctx.ifTrue = self.expression(0)
                        self.state = 172
                        self.match(PyNestMLParser.COLON)
                        self.state = 173
>>>>>>> origin/synapses-feature
                        localctx.ifNot = self.expression(3)
                        pass

             
<<<<<<< HEAD
                self.state = 181
=======
                self.state = 179
>>>>>>> origin/synapses-feature
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class SimpleExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.SimpleExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.string = None # Token
            self.isInf = None # Token

        def functionCall(self):
            return self.getTypedRuleContext(PyNestMLParser.FunctionCallContext,0)


        def BOOLEAN_LITERAL(self):
            return self.getToken(PyNestMLParser.BOOLEAN_LITERAL, 0)

        def UNSIGNED_INTEGER(self):
            return self.getToken(PyNestMLParser.UNSIGNED_INTEGER, 0)

        def FLOAT(self):
            return self.getToken(PyNestMLParser.FLOAT, 0)

        def variable(self):
            return self.getTypedRuleContext(PyNestMLParser.VariableContext,0)


        def STRING_LITERAL(self):
            return self.getToken(PyNestMLParser.STRING_LITERAL, 0)

        def INF_KEYWORD(self):
            return self.getToken(PyNestMLParser.INF_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_simpleExpression

        def accept(self, visitor):
            if hasattr(visitor, "visitSimpleExpression"):
                return visitor.visitSimpleExpression(self)
            else:
                return visitor.visitChildren(self)




    def simpleExpression(self):

        localctx = PyNestMLParser.SimpleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_simpleExpression)
        self._la = 0 # Token type
        try:
<<<<<<< HEAD
            self.state = 191
=======
            self.state = 189
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 182
=======
                self.state = 180
>>>>>>> origin/synapses-feature
                self.functionCall()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 183
=======
                self.state = 181
>>>>>>> origin/synapses-feature
                self.match(PyNestMLParser.BOOLEAN_LITERAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 184
=======
                self.state = 182
>>>>>>> origin/synapses-feature
                _la = self._input.LA(1)
                if not(_la==PyNestMLParser.UNSIGNED_INTEGER or _la==PyNestMLParser.FLOAT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
<<<<<<< HEAD
                self.state = 186
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 185
=======
                self.state = 184
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 183
>>>>>>> origin/synapses-feature
                    self.variable()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
<<<<<<< HEAD
                self.state = 188
=======
                self.state = 186
>>>>>>> origin/synapses-feature
                localctx.string = self.match(PyNestMLParser.STRING_LITERAL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
<<<<<<< HEAD
                self.state = 189
=======
                self.state = 187
>>>>>>> origin/synapses-feature
                localctx.isInf = self.match(PyNestMLParser.INF_KEYWORD)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
<<<<<<< HEAD
                self.state = 190
=======
                self.state = 188
>>>>>>> origin/synapses-feature
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.UnaryOperatorContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.unaryPlus = None # Token
            self.unaryMinus = None # Token
            self.unaryTilde = None # Token

        def PLUS(self):
            return self.getToken(PyNestMLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(PyNestMLParser.MINUS, 0)

        def TILDE(self):
            return self.getToken(PyNestMLParser.TILDE, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_unaryOperator

        def accept(self, visitor):
            if hasattr(visitor, "visitUnaryOperator"):
                return visitor.visitUnaryOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryOperator(self):

        localctx = PyNestMLParser.UnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_unaryOperator)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 196
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.PLUS]:
                self.state = 193
                localctx.unaryPlus = self.match(PyNestMLParser.PLUS)
                pass
            elif token in [PyNestMLParser.MINUS]:
                self.state = 194
                localctx.unaryMinus = self.match(PyNestMLParser.MINUS)
                pass
            elif token in [PyNestMLParser.TILDE]:
                self.state = 195
=======
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.PLUS]:
                self.state = 191
                localctx.unaryPlus = self.match(PyNestMLParser.PLUS)
                pass
            elif token in [PyNestMLParser.MINUS]:
                self.state = 192
                localctx.unaryMinus = self.match(PyNestMLParser.MINUS)
                pass
            elif token in [PyNestMLParser.TILDE]:
                self.state = 193
>>>>>>> origin/synapses-feature
                localctx.unaryTilde = self.match(PyNestMLParser.TILDE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BitOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.BitOperatorContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.bitAnd = None # Token
            self.bitXor = None # Token
            self.bitOr = None # Token
            self.bitShiftLeft = None # Token
            self.bitShiftRight = None # Token

        def AMPERSAND(self):
            return self.getToken(PyNestMLParser.AMPERSAND, 0)

        def CARET(self):
            return self.getToken(PyNestMLParser.CARET, 0)

        def PIPE(self):
            return self.getToken(PyNestMLParser.PIPE, 0)

        def LEFT_LEFT_ANGLE(self):
            return self.getToken(PyNestMLParser.LEFT_LEFT_ANGLE, 0)

        def RIGHT_RIGHT_ANGLE(self):
            return self.getToken(PyNestMLParser.RIGHT_RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_bitOperator

        def accept(self, visitor):
            if hasattr(visitor, "visitBitOperator"):
                return visitor.visitBitOperator(self)
            else:
                return visitor.visitChildren(self)




    def bitOperator(self):

        localctx = PyNestMLParser.BitOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_bitOperator)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 203
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.AMPERSAND]:
                self.state = 198
                localctx.bitAnd = self.match(PyNestMLParser.AMPERSAND)
                pass
            elif token in [PyNestMLParser.CARET]:
                self.state = 199
                localctx.bitXor = self.match(PyNestMLParser.CARET)
                pass
            elif token in [PyNestMLParser.PIPE]:
                self.state = 200
                localctx.bitOr = self.match(PyNestMLParser.PIPE)
                pass
            elif token in [PyNestMLParser.LEFT_LEFT_ANGLE]:
                self.state = 201
                localctx.bitShiftLeft = self.match(PyNestMLParser.LEFT_LEFT_ANGLE)
                pass
            elif token in [PyNestMLParser.RIGHT_RIGHT_ANGLE]:
                self.state = 202
=======
            self.state = 201
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.AMPERSAND]:
                self.state = 196
                localctx.bitAnd = self.match(PyNestMLParser.AMPERSAND)
                pass
            elif token in [PyNestMLParser.CARET]:
                self.state = 197
                localctx.bitXor = self.match(PyNestMLParser.CARET)
                pass
            elif token in [PyNestMLParser.PIPE]:
                self.state = 198
                localctx.bitOr = self.match(PyNestMLParser.PIPE)
                pass
            elif token in [PyNestMLParser.LEFT_LEFT_ANGLE]:
                self.state = 199
                localctx.bitShiftLeft = self.match(PyNestMLParser.LEFT_LEFT_ANGLE)
                pass
            elif token in [PyNestMLParser.RIGHT_RIGHT_ANGLE]:
                self.state = 200
>>>>>>> origin/synapses-feature
                localctx.bitShiftRight = self.match(PyNestMLParser.RIGHT_RIGHT_ANGLE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComparisonOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ComparisonOperatorContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.lt = None # Token
            self.le = None # Token
            self.eq = None # Token
            self.ne = None # Token
            self.ne2 = None # Token
            self.ge = None # Token
            self.gt = None # Token

        def LEFT_ANGLE(self):
            return self.getToken(PyNestMLParser.LEFT_ANGLE, 0)

        def LEFT_ANGLE_EQUALS(self):
            return self.getToken(PyNestMLParser.LEFT_ANGLE_EQUALS, 0)

        def EQUALS_EQUALS(self):
            return self.getToken(PyNestMLParser.EQUALS_EQUALS, 0)

        def EXCLAMATION_EQUALS(self):
            return self.getToken(PyNestMLParser.EXCLAMATION_EQUALS, 0)

        def LEFT_ANGLE_RIGHT_ANGLE(self):
            return self.getToken(PyNestMLParser.LEFT_ANGLE_RIGHT_ANGLE, 0)

        def RIGHT_ANGLE_EQUALS(self):
            return self.getToken(PyNestMLParser.RIGHT_ANGLE_EQUALS, 0)

        def RIGHT_ANGLE(self):
            return self.getToken(PyNestMLParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_comparisonOperator

        def accept(self, visitor):
            if hasattr(visitor, "visitComparisonOperator"):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = PyNestMLParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_comparisonOperator)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 212
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.LEFT_ANGLE]:
                self.state = 205
                localctx.lt = self.match(PyNestMLParser.LEFT_ANGLE)
                pass
            elif token in [PyNestMLParser.LEFT_ANGLE_EQUALS]:
                self.state = 206
                localctx.le = self.match(PyNestMLParser.LEFT_ANGLE_EQUALS)
                pass
            elif token in [PyNestMLParser.EQUALS_EQUALS]:
                self.state = 207
                localctx.eq = self.match(PyNestMLParser.EQUALS_EQUALS)
                pass
            elif token in [PyNestMLParser.EXCLAMATION_EQUALS]:
                self.state = 208
                localctx.ne = self.match(PyNestMLParser.EXCLAMATION_EQUALS)
                pass
            elif token in [PyNestMLParser.LEFT_ANGLE_RIGHT_ANGLE]:
                self.state = 209
                localctx.ne2 = self.match(PyNestMLParser.LEFT_ANGLE_RIGHT_ANGLE)
                pass
            elif token in [PyNestMLParser.RIGHT_ANGLE_EQUALS]:
                self.state = 210
                localctx.ge = self.match(PyNestMLParser.RIGHT_ANGLE_EQUALS)
                pass
            elif token in [PyNestMLParser.RIGHT_ANGLE]:
                self.state = 211
=======
            self.state = 210
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.LEFT_ANGLE]:
                self.state = 203
                localctx.lt = self.match(PyNestMLParser.LEFT_ANGLE)
                pass
            elif token in [PyNestMLParser.LEFT_ANGLE_EQUALS]:
                self.state = 204
                localctx.le = self.match(PyNestMLParser.LEFT_ANGLE_EQUALS)
                pass
            elif token in [PyNestMLParser.EQUALS_EQUALS]:
                self.state = 205
                localctx.eq = self.match(PyNestMLParser.EQUALS_EQUALS)
                pass
            elif token in [PyNestMLParser.EXCLAMATION_EQUALS]:
                self.state = 206
                localctx.ne = self.match(PyNestMLParser.EXCLAMATION_EQUALS)
                pass
            elif token in [PyNestMLParser.LEFT_ANGLE_RIGHT_ANGLE]:
                self.state = 207
                localctx.ne2 = self.match(PyNestMLParser.LEFT_ANGLE_RIGHT_ANGLE)
                pass
            elif token in [PyNestMLParser.RIGHT_ANGLE_EQUALS]:
                self.state = 208
                localctx.ge = self.match(PyNestMLParser.RIGHT_ANGLE_EQUALS)
                pass
            elif token in [PyNestMLParser.RIGHT_ANGLE]:
                self.state = 209
>>>>>>> origin/synapses-feature
                localctx.gt = self.match(PyNestMLParser.RIGHT_ANGLE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicalOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.LogicalOperatorContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.logicalAnd = None # Token
            self.logicalOr = None # Token

        def AND_KEYWORD(self):
            return self.getToken(PyNestMLParser.AND_KEYWORD, 0)

        def OR_KEYWORD(self):
            return self.getToken(PyNestMLParser.OR_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_logicalOperator

        def accept(self, visitor):
            if hasattr(visitor, "visitLogicalOperator"):
                return visitor.visitLogicalOperator(self)
            else:
                return visitor.visitChildren(self)




    def logicalOperator(self):

        localctx = PyNestMLParser.LogicalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_logicalOperator)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 216
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.AND_KEYWORD]:
                self.state = 214
                localctx.logicalAnd = self.match(PyNestMLParser.AND_KEYWORD)
                pass
            elif token in [PyNestMLParser.OR_KEYWORD]:
                self.state = 215
=======
            self.state = 214
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.AND_KEYWORD]:
                self.state = 212
                localctx.logicalAnd = self.match(PyNestMLParser.AND_KEYWORD)
                pass
            elif token in [PyNestMLParser.OR_KEYWORD]:
                self.state = 213
>>>>>>> origin/synapses-feature
                localctx.logicalOr = self.match(PyNestMLParser.OR_KEYWORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.VariableContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def DIFFERENTIAL_ORDER(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.DIFFERENTIAL_ORDER)
            else:
                return self.getToken(PyNestMLParser.DIFFERENTIAL_ORDER, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_variable

        def accept(self, visitor):
            if hasattr(visitor, "visitVariable"):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = PyNestMLParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 218
            localctx.name = self.match(PyNestMLParser.NAME)
            self.state = 222
=======
            self.state = 216
            localctx.name = self.match(PyNestMLParser.NAME)
            self.state = 220
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
<<<<<<< HEAD
                    self.state = 219
                    self.match(PyNestMLParser.DIFFERENTIAL_ORDER) 
                self.state = 224
=======
                    self.state = 217
                    self.match(PyNestMLParser.DIFFERENTIAL_ORDER) 
                self.state = 222
>>>>>>> origin/synapses-feature
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionCallContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.FunctionCallContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.calleeName = None # Token

        def LEFT_PAREN(self):
            return self.getToken(PyNestMLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(PyNestMLParser.RIGHT_PAREN, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.COMMA)
            else:
                return self.getToken(PyNestMLParser.COMMA, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_functionCall

        def accept(self, visitor):
            if hasattr(visitor, "visitFunctionCall"):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = PyNestMLParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 225
            localctx.calleeName = self.match(PyNestMLParser.NAME)
            self.state = 226
            self.match(PyNestMLParser.LEFT_PAREN)
            self.state = 235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.INF_KEYWORD) | (1 << PyNestMLParser.NOT_KEYWORD) | (1 << PyNestMLParser.LEFT_PAREN) | (1 << PyNestMLParser.PLUS) | (1 << PyNestMLParser.TILDE))) != 0) or ((((_la - 74)) & ~0x3f) == 0 and ((1 << (_la - 74)) & ((1 << (PyNestMLParser.MINUS - 74)) | (1 << (PyNestMLParser.BOOLEAN_LITERAL - 74)) | (1 << (PyNestMLParser.STRING_LITERAL - 74)) | (1 << (PyNestMLParser.NAME - 74)) | (1 << (PyNestMLParser.UNSIGNED_INTEGER - 74)) | (1 << (PyNestMLParser.FLOAT - 74)))) != 0):
                self.state = 227
                self.expression(0)
                self.state = 232
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PyNestMLParser.COMMA:
                    self.state = 228
                    self.match(PyNestMLParser.COMMA)
                    self.state = 229
                    self.expression(0)
                    self.state = 234
=======
            self.state = 223
            localctx.calleeName = self.match(PyNestMLParser.NAME)
            self.state = 224
            self.match(PyNestMLParser.LEFT_PAREN)
            self.state = 233
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.INF_KEYWORD) | (1 << PyNestMLParser.NOT_KEYWORD) | (1 << PyNestMLParser.LEFT_PAREN) | (1 << PyNestMLParser.PLUS) | (1 << PyNestMLParser.TILDE))) != 0) or ((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & ((1 << (PyNestMLParser.MINUS - 72)) | (1 << (PyNestMLParser.BOOLEAN_LITERAL - 72)) | (1 << (PyNestMLParser.STRING_LITERAL - 72)) | (1 << (PyNestMLParser.NAME - 72)) | (1 << (PyNestMLParser.UNSIGNED_INTEGER - 72)) | (1 << (PyNestMLParser.FLOAT - 72)))) != 0):
                self.state = 225
                self.expression(0)
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PyNestMLParser.COMMA:
                    self.state = 226
                    self.match(PyNestMLParser.COMMA)
                    self.state = 227
                    self.expression(0)
                    self.state = 232
>>>>>>> origin/synapses-feature
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



<<<<<<< HEAD
            self.state = 237
=======
            self.state = 235
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InlineExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.InlineExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.recordable = None # Token
            self.variableName = None # Token

        def INLINE_KEYWORD(self):
            return self.getToken(PyNestMLParser.INLINE_KEYWORD, 0)

        def dataType(self):
            return self.getTypedRuleContext(PyNestMLParser.DataTypeContext,0)


        def EQUALS(self):
            return self.getToken(PyNestMLParser.EQUALS, 0)

        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def SEMICOLON(self):
            return self.getToken(PyNestMLParser.SEMICOLON, 0)

        def RECORDABLE_KEYWORD(self):
            return self.getToken(PyNestMLParser.RECORDABLE_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_inlineExpression

        def accept(self, visitor):
            if hasattr(visitor, "visitInlineExpression"):
                return visitor.visitInlineExpression(self)
            else:
                return visitor.visitChildren(self)




    def inlineExpression(self):

        localctx = PyNestMLParser.InlineExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_inlineExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.RECORDABLE_KEYWORD:
                self.state = 239
                localctx.recordable = self.match(PyNestMLParser.RECORDABLE_KEYWORD)


            self.state = 242
            self.match(PyNestMLParser.INLINE_KEYWORD)
            self.state = 243
            localctx.variableName = self.match(PyNestMLParser.NAME)
            self.state = 244
            self.dataType()
            self.state = 245
            self.match(PyNestMLParser.EQUALS)
            self.state = 246
            self.expression(0)
            self.state = 248
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.SEMICOLON:
                self.state = 247
=======
            self.state = 238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.RECORDABLE_KEYWORD:
                self.state = 237
                localctx.recordable = self.match(PyNestMLParser.RECORDABLE_KEYWORD)


            self.state = 240
            self.match(PyNestMLParser.FUNCTION_KEYWORD)
            self.state = 241
            localctx.variableName = self.match(PyNestMLParser.NAME)
            self.state = 242
            self.dataType()
            self.state = 243
            self.match(PyNestMLParser.EQUALS)
            self.state = 244
            self.expression(0)
            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.SEMICOLON:
                self.state = 245
>>>>>>> origin/synapses-feature
                self.match(PyNestMLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OdeEquationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.OdeEquationContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.lhs = None # VariableContext
            self.rhs = None # ExpressionContext

        def EQUALS(self):
            return self.getToken(PyNestMLParser.EQUALS, 0)

        def variable(self):
            return self.getTypedRuleContext(PyNestMLParser.VariableContext,0)


        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(PyNestMLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_odeEquation

        def accept(self, visitor):
            if hasattr(visitor, "visitOdeEquation"):
                return visitor.visitOdeEquation(self)
            else:
                return visitor.visitChildren(self)




    def odeEquation(self):

        localctx = PyNestMLParser.OdeEquationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_odeEquation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 250
            localctx.lhs = self.variable()
            self.state = 251
            self.match(PyNestMLParser.EQUALS)
            self.state = 252
            localctx.rhs = self.expression(0)
            self.state = 254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.SEMICOLON:
                self.state = 253
=======
            self.state = 248
            localctx.lhs = self.variable()
            self.state = 249
            self.match(PyNestMLParser.EQUALS)
            self.state = 250
            localctx.rhs = self.expression(0)
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.SEMICOLON:
                self.state = 251
>>>>>>> origin/synapses-feature
                self.match(PyNestMLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OdeShapeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.OdeShapeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SHAPE_KEYWORD(self):
            return self.getToken(PyNestMLParser.SHAPE_KEYWORD, 0)

        def variable(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.VariableContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.VariableContext,i)


        def EQUALS(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.EQUALS)
            else:
                return self.getToken(PyNestMLParser.EQUALS, i)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.COMMA)
            else:
                return self.getToken(PyNestMLParser.COMMA, i)

        def SEMICOLON(self):
            return self.getToken(PyNestMLParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_odeShape

        def accept(self, visitor):
            if hasattr(visitor, "visitOdeShape"):
                return visitor.visitOdeShape(self)
            else:
                return visitor.visitChildren(self)




    def odeShape(self):

        localctx = PyNestMLParser.OdeShapeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_odeShape)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 256
            self.match(PyNestMLParser.SHAPE_KEYWORD)
            self.state = 257
            self.variable()
            self.state = 258
            self.match(PyNestMLParser.EQUALS)
            self.state = 259
            self.expression(0)
            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.COMMA:
                self.state = 260
                self.match(PyNestMLParser.COMMA)
                self.state = 261
                self.variable()
                self.state = 262
                self.match(PyNestMLParser.EQUALS)
                self.state = 263
                self.expression(0)
                self.state = 269
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.SEMICOLON:
                self.state = 270
=======
            self.state = 254
            self.match(PyNestMLParser.SHAPE_KEYWORD)
            self.state = 255
            localctx.lhs = self.variable()
            self.state = 256
            self.match(PyNestMLParser.EQUALS)
            self.state = 257
            localctx.rhs = self.expression(0)
            self.state = 259
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.SEMICOLON:
                self.state = 258
>>>>>>> origin/synapses-feature
                self.match(PyNestMLParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.BlockContext, self).__init__(parent, invokingState)
            self.parser = parser

        def stmt(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.StmtContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.StmtContext,i)


        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_block

        def accept(self, visitor):
            if hasattr(visitor, "visitBlock"):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = PyNestMLParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.RETURN_KEYWORD) | (1 << PyNestMLParser.IF_KEYWORD) | (1 << PyNestMLParser.FOR_KEYWORD) | (1 << PyNestMLParser.WHILE_KEYWORD) | (1 << PyNestMLParser.RECORDABLE_KEYWORD))) != 0) or _la==PyNestMLParser.NAME:
                self.state = 275
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.FUNCTION_KEYWORD, PyNestMLParser.RETURN_KEYWORD, PyNestMLParser.IF_KEYWORD, PyNestMLParser.FOR_KEYWORD, PyNestMLParser.WHILE_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD, PyNestMLParser.NAME]:
                    self.state = 273
                    self.stmt()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 274
=======
            self.state = 265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.RETURN_KEYWORD) | (1 << PyNestMLParser.IF_KEYWORD) | (1 << PyNestMLParser.FOR_KEYWORD) | (1 << PyNestMLParser.WHILE_KEYWORD) | (1 << PyNestMLParser.RECORDABLE_KEYWORD))) != 0) or _la==PyNestMLParser.NAME:
                self.state = 263
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.FUNCTION_KEYWORD, PyNestMLParser.RETURN_KEYWORD, PyNestMLParser.IF_KEYWORD, PyNestMLParser.FOR_KEYWORD, PyNestMLParser.WHILE_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD, PyNestMLParser.NAME]:
                    self.state = 261
                    self.stmt()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 262
>>>>>>> origin/synapses-feature
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 279
=======
                self.state = 267
>>>>>>> origin/synapses-feature
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.StmtContext, self).__init__(parent, invokingState)
            self.parser = parser

        def smallStmt(self):
            return self.getTypedRuleContext(PyNestMLParser.SmallStmtContext,0)


        def compoundStmt(self):
            return self.getTypedRuleContext(PyNestMLParser.CompoundStmtContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_stmt

        def accept(self, visitor):
            if hasattr(visitor, "visitStmt"):
                return visitor.visitStmt(self)
            else:
                return visitor.visitChildren(self)




    def stmt(self):

        localctx = PyNestMLParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_stmt)
        try:
<<<<<<< HEAD
            self.state = 282
=======
            self.state = 270
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.FUNCTION_KEYWORD, PyNestMLParser.RETURN_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD, PyNestMLParser.NAME]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 280
=======
                self.state = 268
>>>>>>> origin/synapses-feature
                self.smallStmt()
                pass
            elif token in [PyNestMLParser.IF_KEYWORD, PyNestMLParser.FOR_KEYWORD, PyNestMLParser.WHILE_KEYWORD]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 281
=======
                self.state = 269
>>>>>>> origin/synapses-feature
                self.compoundStmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundStmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.CompoundStmtContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ifStmt(self):
            return self.getTypedRuleContext(PyNestMLParser.IfStmtContext,0)


        def forStmt(self):
            return self.getTypedRuleContext(PyNestMLParser.ForStmtContext,0)


        def whileStmt(self):
            return self.getTypedRuleContext(PyNestMLParser.WhileStmtContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_compoundStmt

        def accept(self, visitor):
            if hasattr(visitor, "visitCompoundStmt"):
                return visitor.visitCompoundStmt(self)
            else:
                return visitor.visitChildren(self)




    def compoundStmt(self):

        localctx = PyNestMLParser.CompoundStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_compoundStmt)
        try:
<<<<<<< HEAD
            self.state = 287
=======
            self.state = 275
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.IF_KEYWORD]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 284
=======
                self.state = 272
>>>>>>> origin/synapses-feature
                self.ifStmt()
                pass
            elif token in [PyNestMLParser.FOR_KEYWORD]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 285
=======
                self.state = 273
>>>>>>> origin/synapses-feature
                self.forStmt()
                pass
            elif token in [PyNestMLParser.WHILE_KEYWORD]:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 286
=======
                self.state = 274
>>>>>>> origin/synapses-feature
                self.whileStmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SmallStmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.SmallStmtContext, self).__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(PyNestMLParser.AssignmentContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(PyNestMLParser.FunctionCallContext,0)


        def declaration(self):
            return self.getTypedRuleContext(PyNestMLParser.DeclarationContext,0)


        def returnStmt(self):
            return self.getTypedRuleContext(PyNestMLParser.ReturnStmtContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_smallStmt

        def accept(self, visitor):
            if hasattr(visitor, "visitSmallStmt"):
                return visitor.visitSmallStmt(self)
            else:
                return visitor.visitChildren(self)




    def smallStmt(self):

        localctx = PyNestMLParser.SmallStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_smallStmt)
        try:
<<<<<<< HEAD
            self.state = 293
=======
            self.state = 281
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 289
=======
                self.state = 277
>>>>>>> origin/synapses-feature
                self.assignment()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 290
=======
                self.state = 278
>>>>>>> origin/synapses-feature
                self.functionCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 291
=======
                self.state = 279
>>>>>>> origin/synapses-feature
                self.declaration()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
<<<<<<< HEAD
                self.state = 292
=======
                self.state = 280
>>>>>>> origin/synapses-feature
                self.returnStmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.AssignmentContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.lhs_variable = None # VariableContext
            self.directAssignment = None # Token
            self.compoundSum = None # Token
            self.compoundMinus = None # Token
            self.compoundProduct = None # Token
            self.compoundQuotient = None # Token

        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def variable(self):
            return self.getTypedRuleContext(PyNestMLParser.VariableContext,0)


        def EQUALS(self):
            return self.getToken(PyNestMLParser.EQUALS, 0)

        def PLUS_EQUALS(self):
            return self.getToken(PyNestMLParser.PLUS_EQUALS, 0)

        def MINUS_EQUALS(self):
            return self.getToken(PyNestMLParser.MINUS_EQUALS, 0)

        def STAR_EQUALS(self):
            return self.getToken(PyNestMLParser.STAR_EQUALS, 0)

        def FORWARD_SLASH_EQUALS(self):
            return self.getToken(PyNestMLParser.FORWARD_SLASH_EQUALS, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_assignment

        def accept(self, visitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = PyNestMLParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 295
            localctx.lhs_variable = self.variable()
            self.state = 301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.EQUALS]:
                self.state = 296
                localctx.directAssignment = self.match(PyNestMLParser.EQUALS)
                pass
            elif token in [PyNestMLParser.PLUS_EQUALS]:
                self.state = 297
                localctx.compoundSum = self.match(PyNestMLParser.PLUS_EQUALS)
                pass
            elif token in [PyNestMLParser.MINUS_EQUALS]:
                self.state = 298
                localctx.compoundMinus = self.match(PyNestMLParser.MINUS_EQUALS)
                pass
            elif token in [PyNestMLParser.STAR_EQUALS]:
                self.state = 299
                localctx.compoundProduct = self.match(PyNestMLParser.STAR_EQUALS)
                pass
            elif token in [PyNestMLParser.FORWARD_SLASH_EQUALS]:
                self.state = 300
=======
            self.state = 283
            localctx.lhs_variable = self.variable()
            self.state = 289
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.EQUALS]:
                self.state = 284
                localctx.directAssignment = self.match(PyNestMLParser.EQUALS)
                pass
            elif token in [PyNestMLParser.PLUS_EQUALS]:
                self.state = 285
                localctx.compoundSum = self.match(PyNestMLParser.PLUS_EQUALS)
                pass
            elif token in [PyNestMLParser.MINUS_EQUALS]:
                self.state = 286
                localctx.compoundMinus = self.match(PyNestMLParser.MINUS_EQUALS)
                pass
            elif token in [PyNestMLParser.STAR_EQUALS]:
                self.state = 287
                localctx.compoundProduct = self.match(PyNestMLParser.STAR_EQUALS)
                pass
            elif token in [PyNestMLParser.FORWARD_SLASH_EQUALS]:
                self.state = 288
>>>>>>> origin/synapses-feature
                localctx.compoundQuotient = self.match(PyNestMLParser.FORWARD_SLASH_EQUALS)
                pass
            else:
                raise NoViableAltException(self)

<<<<<<< HEAD
            self.state = 303
=======
            self.state = 291
>>>>>>> origin/synapses-feature
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.DeclarationContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.isRecordable = None # Token
            self.isFunction = None # Token
            self.sizeParameter = None # Token
            self.rhs = None # ExpressionContext
            self.invariant = None # ExpressionContext
            self.decorator = None # AnyDecoratorContext

        def variable(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.VariableContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.VariableContext,i)


        def dataType(self):
            return self.getTypedRuleContext(PyNestMLParser.DataTypeContext,0)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.COMMA)
            else:
                return self.getToken(PyNestMLParser.COMMA, i)

        def LEFT_SQUARE_BRACKET(self):
            return self.getToken(PyNestMLParser.LEFT_SQUARE_BRACKET, 0)

        def RIGHT_SQUARE_BRACKET(self):
            return self.getToken(PyNestMLParser.RIGHT_SQUARE_BRACKET, 0)

        def EQUALS(self):
            return self.getToken(PyNestMLParser.EQUALS, 0)

        def LEFT_LEFT_SQUARE(self):
            return self.getToken(PyNestMLParser.LEFT_LEFT_SQUARE, 0)

        def RIGHT_RIGHT_SQUARE(self):
            return self.getToken(PyNestMLParser.RIGHT_RIGHT_SQUARE, 0)

        def RECORDABLE_KEYWORD(self):
            return self.getToken(PyNestMLParser.RECORDABLE_KEYWORD, 0)

        def FUNCTION_KEYWORD(self):
            return self.getToken(PyNestMLParser.FUNCTION_KEYWORD, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,i)


        def anyDecorator(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.AnyDecoratorContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.AnyDecoratorContext,i)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_declaration

        def accept(self, visitor):
            if hasattr(visitor, "visitDeclaration"):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = PyNestMLParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.RECORDABLE_KEYWORD:
                self.state = 305
                localctx.isRecordable = self.match(PyNestMLParser.RECORDABLE_KEYWORD)


            self.state = 309
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.FUNCTION_KEYWORD:
                self.state = 308
                localctx.isFunction = self.match(PyNestMLParser.FUNCTION_KEYWORD)


            self.state = 311
            self.variable()
            self.state = 316
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.COMMA:
                self.state = 312
                self.match(PyNestMLParser.COMMA)
                self.state = 313
                self.variable()
                self.state = 318
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 319
            self.dataType()
            self.state = 323
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.LEFT_SQUARE_BRACKET:
                self.state = 320
                self.match(PyNestMLParser.LEFT_SQUARE_BRACKET)
                self.state = 321
                localctx.sizeParameter = self.match(PyNestMLParser.NAME)
                self.state = 322
                self.match(PyNestMLParser.RIGHT_SQUARE_BRACKET)


            self.state = 327
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.EQUALS:
                self.state = 325
                self.match(PyNestMLParser.EQUALS)
                self.state = 326
                localctx.rhs = self.expression(0)


            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.LEFT_LEFT_SQUARE:
                self.state = 329
                self.match(PyNestMLParser.LEFT_LEFT_SQUARE)
                self.state = 330
                localctx.invariant = self.expression(0)
                self.state = 331
                self.match(PyNestMLParser.RIGHT_RIGHT_SQUARE)


            self.state = 338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.DECORATOR_HOMOGENEOUS) | (1 << PyNestMLParser.DECORATOR_HETEROGENEOUS) | (1 << PyNestMLParser.AT))) != 0):
                self.state = 335
                localctx.decorator = self.anyDecorator()
                self.state = 340
=======
            self.state = 294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.RECORDABLE_KEYWORD:
                self.state = 293
                localctx.isRecordable = self.match(PyNestMLParser.RECORDABLE_KEYWORD)


            self.state = 297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.FUNCTION_KEYWORD:
                self.state = 296
                localctx.isFunction = self.match(PyNestMLParser.FUNCTION_KEYWORD)


            self.state = 299
            self.variable()
            self.state = 304
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.COMMA:
                self.state = 300
                self.match(PyNestMLParser.COMMA)
                self.state = 301
                self.variable()
                self.state = 306
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 307
            self.dataType()
            self.state = 311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.LEFT_SQUARE_BRACKET:
                self.state = 308
                self.match(PyNestMLParser.LEFT_SQUARE_BRACKET)
                self.state = 309
                localctx.sizeParameter = self.match(PyNestMLParser.NAME)
                self.state = 310
                self.match(PyNestMLParser.RIGHT_SQUARE_BRACKET)


            self.state = 315
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.EQUALS:
                self.state = 313
                self.match(PyNestMLParser.EQUALS)
                self.state = 314
                localctx.rhs = self.expression(0)


            self.state = 321
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.LEFT_LEFT_SQUARE:
                self.state = 317
                self.match(PyNestMLParser.LEFT_LEFT_SQUARE)
                self.state = 318
                localctx.invariant = self.expression(0)
                self.state = 319
                self.match(PyNestMLParser.RIGHT_RIGHT_SQUARE)


            self.state = 326
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.DECORATOR_HOMOGENEOUS) | (1 << PyNestMLParser.DECORATOR_HETEROGENEOUS) | (1 << PyNestMLParser.AT))) != 0):
                self.state = 323
                localctx.decorator = self.anyDecorator()
                self.state = 328
>>>>>>> origin/synapses-feature
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnyDecoratorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.AnyDecoratorContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DECORATOR_HOMOGENEOUS(self):
            return self.getToken(PyNestMLParser.DECORATOR_HOMOGENEOUS, 0)

        def DECORATOR_HETEROGENEOUS(self):
            return self.getToken(PyNestMLParser.DECORATOR_HETEROGENEOUS, 0)

        def AT(self):
            return self.getToken(PyNestMLParser.AT, 0)

        def namespaceDecoratorNamespace(self):
            return self.getTypedRuleContext(PyNestMLParser.NamespaceDecoratorNamespaceContext,0)


        def DOUBLE_COLON(self):
            return self.getToken(PyNestMLParser.DOUBLE_COLON, 0)

        def namespaceDecoratorName(self):
            return self.getTypedRuleContext(PyNestMLParser.NamespaceDecoratorNameContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_anyDecorator

        def accept(self, visitor):
            if hasattr(visitor, "visitAnyDecorator"):
                return visitor.visitAnyDecorator(self)
            else:
                return visitor.visitChildren(self)




    def anyDecorator(self):

        localctx = PyNestMLParser.AnyDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_anyDecorator)
        try:
<<<<<<< HEAD
            self.state = 348
=======
            self.state = 336
>>>>>>> origin/synapses-feature
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.DECORATOR_HOMOGENEOUS]:
                self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
                self.state = 341
=======
                self.state = 329
>>>>>>> origin/synapses-feature
                self.match(PyNestMLParser.DECORATOR_HOMOGENEOUS)
                pass
            elif token in [PyNestMLParser.DECORATOR_HETEROGENEOUS]:
                self.enterOuterAlt(localctx, 2)
<<<<<<< HEAD
                self.state = 342
=======
                self.state = 330
>>>>>>> origin/synapses-feature
                self.match(PyNestMLParser.DECORATOR_HETEROGENEOUS)
                pass
            elif token in [PyNestMLParser.AT]:
                self.enterOuterAlt(localctx, 3)
<<<<<<< HEAD
                self.state = 343
                self.match(PyNestMLParser.AT)
                self.state = 344
                self.namespaceDecoratorNamespace()
                self.state = 345
                self.match(PyNestMLParser.DOUBLE_COLON)
                self.state = 346
=======
                self.state = 331
                self.match(PyNestMLParser.AT)
                self.state = 332
                self.namespaceDecoratorNamespace()
                self.state = 333
                self.match(PyNestMLParser.DOUBLE_COLON)
                self.state = 334
>>>>>>> origin/synapses-feature
                self.namespaceDecoratorName()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NamespaceDecoratorNamespaceContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.NamespaceDecoratorNamespaceContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_namespaceDecoratorNamespace

        def accept(self, visitor):
            if hasattr(visitor, "visitNamespaceDecoratorNamespace"):
                return visitor.visitNamespaceDecoratorNamespace(self)
            else:
                return visitor.visitChildren(self)




    def namespaceDecoratorNamespace(self):

        localctx = PyNestMLParser.NamespaceDecoratorNamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_namespaceDecoratorNamespace)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 350
=======
            self.state = 338
>>>>>>> origin/synapses-feature
            localctx.name = self.match(PyNestMLParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NamespaceDecoratorNameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.NamespaceDecoratorNameContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_namespaceDecoratorName

        def accept(self, visitor):
            if hasattr(visitor, "visitNamespaceDecoratorName"):
                return visitor.visitNamespaceDecoratorName(self)
            else:
                return visitor.visitChildren(self)




    def namespaceDecoratorName(self):

        localctx = PyNestMLParser.NamespaceDecoratorNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_namespaceDecoratorName)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 352
=======
            self.state = 340
>>>>>>> origin/synapses-feature
            localctx.name = self.match(PyNestMLParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnStmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ReturnStmtContext, self).__init__(parent, invokingState)
            self.parser = parser

        def RETURN_KEYWORD(self):
            return self.getToken(PyNestMLParser.RETURN_KEYWORD, 0)

        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_returnStmt

        def accept(self, visitor):
            if hasattr(visitor, "visitReturnStmt"):
                return visitor.visitReturnStmt(self)
            else:
                return visitor.visitChildren(self)




    def returnStmt(self):

        localctx = PyNestMLParser.ReturnStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_returnStmt)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 354
            self.match(PyNestMLParser.RETURN_KEYWORD)
            self.state = 356
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.state = 355
=======
            self.state = 342
            self.match(PyNestMLParser.RETURN_KEYWORD)
            self.state = 344
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.state = 343
>>>>>>> origin/synapses-feature
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfStmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.IfStmtContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ifClause(self):
            return self.getTypedRuleContext(PyNestMLParser.IfClauseContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def elifClause(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ElifClauseContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ElifClauseContext,i)


        def elseClause(self):
            return self.getTypedRuleContext(PyNestMLParser.ElseClauseContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_ifStmt

        def accept(self, visitor):
            if hasattr(visitor, "visitIfStmt"):
                return visitor.visitIfStmt(self)
            else:
                return visitor.visitChildren(self)




    def ifStmt(self):

        localctx = PyNestMLParser.IfStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_ifStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 358
            self.ifClause()
            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.ELIF_KEYWORD:
                self.state = 359
                self.elifClause()
                self.state = 364
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 366
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.ELSE_KEYWORD:
                self.state = 365
                self.elseClause()


            self.state = 368
=======
            self.state = 346
            self.ifClause()
            self.state = 350
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.ELIF_KEYWORD:
                self.state = 347
                self.elifClause()
                self.state = 352
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.ELSE_KEYWORD:
                self.state = 353
                self.elseClause()


            self.state = 356
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfClauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.IfClauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IF_KEYWORD(self):
            return self.getToken(PyNestMLParser.IF_KEYWORD, 0)

        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_ifClause

        def accept(self, visitor):
            if hasattr(visitor, "visitIfClause"):
                return visitor.visitIfClause(self)
            else:
                return visitor.visitChildren(self)




    def ifClause(self):

        localctx = PyNestMLParser.IfClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_ifClause)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 370
            self.match(PyNestMLParser.IF_KEYWORD)
            self.state = 371
            self.expression(0)
            self.state = 372
            self.match(PyNestMLParser.COLON)
            self.state = 373
=======
            self.state = 358
            self.match(PyNestMLParser.IF_KEYWORD)
            self.state = 359
            self.expression(0)
            self.state = 360
            self.match(PyNestMLParser.COLON)
            self.state = 361
>>>>>>> origin/synapses-feature
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElifClauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ElifClauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ELIF_KEYWORD(self):
            return self.getToken(PyNestMLParser.ELIF_KEYWORD, 0)

        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_elifClause

        def accept(self, visitor):
            if hasattr(visitor, "visitElifClause"):
                return visitor.visitElifClause(self)
            else:
                return visitor.visitChildren(self)




    def elifClause(self):

        localctx = PyNestMLParser.ElifClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_elifClause)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 375
            self.match(PyNestMLParser.ELIF_KEYWORD)
            self.state = 376
            self.expression(0)
            self.state = 377
            self.match(PyNestMLParser.COLON)
            self.state = 378
=======
            self.state = 363
            self.match(PyNestMLParser.ELIF_KEYWORD)
            self.state = 364
            self.expression(0)
            self.state = 365
            self.match(PyNestMLParser.COLON)
            self.state = 366
>>>>>>> origin/synapses-feature
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ElseClauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ElseClauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ELSE_KEYWORD(self):
            return self.getToken(PyNestMLParser.ELSE_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_elseClause

        def accept(self, visitor):
            if hasattr(visitor, "visitElseClause"):
                return visitor.visitElseClause(self)
            else:
                return visitor.visitChildren(self)




    def elseClause(self):

        localctx = PyNestMLParser.ElseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_elseClause)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 380
            self.match(PyNestMLParser.ELSE_KEYWORD)
            self.state = 381
            self.match(PyNestMLParser.COLON)
            self.state = 382
=======
            self.state = 368
            self.match(PyNestMLParser.ELSE_KEYWORD)
            self.state = 369
            self.match(PyNestMLParser.COLON)
            self.state = 370
>>>>>>> origin/synapses-feature
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForStmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ForStmtContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.var = None # Token
            self.start_from = None # ExpressionContext
            self.end_at = None # ExpressionContext
            self.negative = None # Token

        def FOR_KEYWORD(self):
            return self.getToken(PyNestMLParser.FOR_KEYWORD, 0)

        def IN_KEYWORD(self):
            return self.getToken(PyNestMLParser.IN_KEYWORD, 0)

        def ELLIPSIS(self):
            return self.getToken(PyNestMLParser.ELLIPSIS, 0)

        def STEP_KEYWORD(self):
            return self.getToken(PyNestMLParser.STEP_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,i)


        def UNSIGNED_INTEGER(self):
            return self.getToken(PyNestMLParser.UNSIGNED_INTEGER, 0)

        def FLOAT(self):
            return self.getToken(PyNestMLParser.FLOAT, 0)

        def MINUS(self):
            return self.getToken(PyNestMLParser.MINUS, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_forStmt

        def accept(self, visitor):
            if hasattr(visitor, "visitForStmt"):
                return visitor.visitForStmt(self)
            else:
                return visitor.visitChildren(self)




    def forStmt(self):

        localctx = PyNestMLParser.ForStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_forStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 384
            self.match(PyNestMLParser.FOR_KEYWORD)
            self.state = 385
            localctx.var = self.match(PyNestMLParser.NAME)
            self.state = 386
            self.match(PyNestMLParser.IN_KEYWORD)
            self.state = 387
            localctx.start_from = self.expression(0)
            self.state = 388
            self.match(PyNestMLParser.ELLIPSIS)
            self.state = 389
            localctx.end_at = self.expression(0)
            self.state = 390
            self.match(PyNestMLParser.STEP_KEYWORD)

            self.state = 392
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.MINUS:
                self.state = 391
                localctx.negative = self.match(PyNestMLParser.MINUS)


            self.state = 394
=======
            self.state = 372
            self.match(PyNestMLParser.FOR_KEYWORD)
            self.state = 373
            localctx.var = self.match(PyNestMLParser.NAME)
            self.state = 374
            self.match(PyNestMLParser.IN_KEYWORD)
            self.state = 375
            localctx.start_from = self.expression(0)
            self.state = 376
            self.match(PyNestMLParser.ELLIPSIS)
            self.state = 377
            localctx.end_at = self.expression(0)
            self.state = 378
            self.match(PyNestMLParser.STEP_KEYWORD)

            self.state = 380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.MINUS:
                self.state = 379
                localctx.negative = self.match(PyNestMLParser.MINUS)


            self.state = 382
>>>>>>> origin/synapses-feature
            _la = self._input.LA(1)
            if not(_la==PyNestMLParser.UNSIGNED_INTEGER or _la==PyNestMLParser.FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
<<<<<<< HEAD
            self.state = 395
            self.match(PyNestMLParser.COLON)
            self.state = 396
            self.block()
            self.state = 397
=======
            self.state = 383
            self.match(PyNestMLParser.COLON)
            self.state = 384
            self.block()
            self.state = 385
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhileStmtContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.WhileStmtContext, self).__init__(parent, invokingState)
            self.parser = parser

        def WHILE_KEYWORD(self):
            return self.getToken(PyNestMLParser.WHILE_KEYWORD, 0)

        def expression(self):
            return self.getTypedRuleContext(PyNestMLParser.ExpressionContext,0)


        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_whileStmt

        def accept(self, visitor):
            if hasattr(visitor, "visitWhileStmt"):
                return visitor.visitWhileStmt(self)
            else:
                return visitor.visitChildren(self)




    def whileStmt(self):

        localctx = PyNestMLParser.WhileStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_whileStmt)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 399
            self.match(PyNestMLParser.WHILE_KEYWORD)
            self.state = 400
            self.expression(0)
            self.state = 401
            self.match(PyNestMLParser.COLON)
            self.state = 402
            self.block()
            self.state = 403
=======
            self.state = 387
            self.match(PyNestMLParser.WHILE_KEYWORD)
            self.state = 388
            self.expression(0)
            self.state = 389
            self.match(PyNestMLParser.COLON)
            self.state = 390
            self.block()
            self.state = 391
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NestMLCompilationUnitContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.NestMLCompilationUnitContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(PyNestMLParser.EOF, 0)

        def neuron(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.NeuronContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.NeuronContext,i)


        def synapse(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.SynapseContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.SynapseContext,i)


        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_nestMLCompilationUnit

        def accept(self, visitor):
            if hasattr(visitor, "visitNestMLCompilationUnit"):
                return visitor.visitNestMLCompilationUnit(self)
            else:
                return visitor.visitChildren(self)




    def nestMLCompilationUnit(self):

        localctx = PyNestMLParser.NestMLCompilationUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_nestMLCompilationUnit)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.NEURON_KEYWORD) | (1 << PyNestMLParser.SYNAPSE_KEYWORD))) != 0):
                self.state = 408
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NEURON_KEYWORD]:
                    self.state = 405
                    self.neuron()
                    pass
                elif token in [PyNestMLParser.SYNAPSE_KEYWORD]:
                    self.state = 406
                    self.synapse()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 407
=======
            self.state = 398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.NEURON_KEYWORD) | (1 << PyNestMLParser.SYNAPSE_KEYWORD))) != 0):
                self.state = 396
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NEURON_KEYWORD]:
                    self.state = 393
                    self.neuron()
                    pass
                elif token in [PyNestMLParser.SYNAPSE_KEYWORD]:
                    self.state = 394
                    self.synapse()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 395
>>>>>>> origin/synapses-feature
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 412
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 413
=======
                self.state = 400
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 401
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NeuronContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.NeuronContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NEURON_KEYWORD(self):
            return self.getToken(PyNestMLParser.NEURON_KEYWORD, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def body(self):
            return self.getTypedRuleContext(PyNestMLParser.BodyContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_neuron

        def accept(self, visitor):
            if hasattr(visitor, "visitNeuron"):
                return visitor.visitNeuron(self)
            else:
                return visitor.visitChildren(self)




    def neuron(self):

        localctx = PyNestMLParser.NeuronContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_neuron)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 415
            self.match(PyNestMLParser.NEURON_KEYWORD)
            self.state = 416
            self.match(PyNestMLParser.NAME)
            self.state = 417
=======
            self.state = 403
            self.match(PyNestMLParser.NEURON_KEYWORD)
            self.state = 404
            self.match(PyNestMLParser.NAME)
            self.state = 405
>>>>>>> origin/synapses-feature
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.BodyContext, self).__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def blockWithVariables(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.BlockWithVariablesContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.BlockWithVariablesContext,i)


        def equationsBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.EquationsBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.EquationsBlockContext,i)


        def inputBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.InputBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.InputBlockContext,i)


        def outputBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.OutputBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.OutputBlockContext,i)


        def updateBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.UpdateBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.UpdateBlockContext,i)


        def function(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.FunctionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.FunctionContext,i)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_body

        def accept(self, visitor):
            if hasattr(visitor, "visitBody"):
                return visitor.visitBody(self)
            else:
                return visitor.visitChildren(self)




    def body(self):

        localctx = PyNestMLParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 419
            self.match(PyNestMLParser.COLON)
            self.state = 429
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.STATE_KEYWORD) | (1 << PyNestMLParser.PARAMETERS_KEYWORD) | (1 << PyNestMLParser.INTERNALS_KEYWORD) | (1 << PyNestMLParser.INITIAL_VALUES_KEYWORD) | (1 << PyNestMLParser.UPDATE_KEYWORD) | (1 << PyNestMLParser.EQUATIONS_KEYWORD) | (1 << PyNestMLParser.INPUT_KEYWORD) | (1 << PyNestMLParser.OUTPUT_KEYWORD))) != 0):
                self.state = 427
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NEWLINE]:
                    self.state = 420
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                elif token in [PyNestMLParser.STATE_KEYWORD, PyNestMLParser.PARAMETERS_KEYWORD, PyNestMLParser.INTERNALS_KEYWORD, PyNestMLParser.INITIAL_VALUES_KEYWORD]:
                    self.state = 421
                    self.blockWithVariables()
                    pass
                elif token in [PyNestMLParser.EQUATIONS_KEYWORD]:
                    self.state = 422
                    self.equationsBlock()
                    pass
                elif token in [PyNestMLParser.INPUT_KEYWORD]:
                    self.state = 423
                    self.inputBlock()
                    pass
                elif token in [PyNestMLParser.OUTPUT_KEYWORD]:
                    self.state = 424
                    self.outputBlock()
                    pass
                elif token in [PyNestMLParser.UPDATE_KEYWORD]:
                    self.state = 425
                    self.updateBlock()
                    pass
                elif token in [PyNestMLParser.FUNCTION_KEYWORD]:
                    self.state = 426
=======
            self.state = 407
            self.match(PyNestMLParser.COLON)
            self.state = 417
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.STATE_KEYWORD) | (1 << PyNestMLParser.PARAMETERS_KEYWORD) | (1 << PyNestMLParser.INTERNALS_KEYWORD) | (1 << PyNestMLParser.INITIAL_VALUES_KEYWORD) | (1 << PyNestMLParser.UPDATE_KEYWORD) | (1 << PyNestMLParser.EQUATIONS_KEYWORD) | (1 << PyNestMLParser.INPUT_KEYWORD) | (1 << PyNestMLParser.OUTPUT_KEYWORD))) != 0):
                self.state = 415
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NEWLINE]:
                    self.state = 408
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                elif token in [PyNestMLParser.STATE_KEYWORD, PyNestMLParser.PARAMETERS_KEYWORD, PyNestMLParser.INTERNALS_KEYWORD, PyNestMLParser.INITIAL_VALUES_KEYWORD]:
                    self.state = 409
                    self.blockWithVariables()
                    pass
                elif token in [PyNestMLParser.EQUATIONS_KEYWORD]:
                    self.state = 410
                    self.equationsBlock()
                    pass
                elif token in [PyNestMLParser.INPUT_KEYWORD]:
                    self.state = 411
                    self.inputBlock()
                    pass
                elif token in [PyNestMLParser.OUTPUT_KEYWORD]:
                    self.state = 412
                    self.outputBlock()
                    pass
                elif token in [PyNestMLParser.UPDATE_KEYWORD]:
                    self.state = 413
                    self.updateBlock()
                    pass
                elif token in [PyNestMLParser.FUNCTION_KEYWORD]:
                    self.state = 414
>>>>>>> origin/synapses-feature
                    self.function()
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 431
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 432
=======
                self.state = 419
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 420
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SynapseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.SynapseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SYNAPSE_KEYWORD(self):
            return self.getToken(PyNestMLParser.SYNAPSE_KEYWORD, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def synapseBody(self):
            return self.getTypedRuleContext(PyNestMLParser.SynapseBodyContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_synapse

        def accept(self, visitor):
            if hasattr(visitor, "visitSynapse"):
                return visitor.visitSynapse(self)
            else:
                return visitor.visitChildren(self)




    def synapse(self):

        localctx = PyNestMLParser.SynapseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_synapse)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 434
            self.match(PyNestMLParser.SYNAPSE_KEYWORD)
            self.state = 435
            self.match(PyNestMLParser.NAME)
            self.state = 436
            self.match(PyNestMLParser.COLON)
            self.state = 437
=======
            self.state = 422
            self.match(PyNestMLParser.SYNAPSE_KEYWORD)
            self.state = 423
            self.match(PyNestMLParser.NAME)
            self.state = 424
            self.match(PyNestMLParser.COLON)
            self.state = 425
>>>>>>> origin/synapses-feature
            self.synapseBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SynapseBodyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.SynapseBodyContext, self).__init__(parent, invokingState)
            self.parser = parser

        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def blockWithVariables(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.BlockWithVariablesContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.BlockWithVariablesContext,i)


        def equationsBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.EquationsBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.EquationsBlockContext,i)


        def inputBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.InputBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.InputBlockContext,i)


        def updateBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.UpdateBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.UpdateBlockContext,i)


        def function(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.FunctionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.FunctionContext,i)


        def preReceiveBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.PreReceiveBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.PreReceiveBlockContext,i)


        def postReceiveBlock(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.PostReceiveBlockContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.PostReceiveBlockContext,i)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_synapseBody

        def accept(self, visitor):
            if hasattr(visitor, "visitSynapseBody"):
                return visitor.visitSynapseBody(self)
            else:
                return visitor.visitChildren(self)




    def synapseBody(self):

        localctx = PyNestMLParser.SynapseBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_synapseBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 449
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.STATE_KEYWORD) | (1 << PyNestMLParser.PARAMETERS_KEYWORD) | (1 << PyNestMLParser.INTERNALS_KEYWORD) | (1 << PyNestMLParser.INITIAL_VALUES_KEYWORD) | (1 << PyNestMLParser.UPDATE_KEYWORD) | (1 << PyNestMLParser.EQUATIONS_KEYWORD) | (1 << PyNestMLParser.INPUT_KEYWORD) | (1 << PyNestMLParser.PRE_RECEIVE_KEYWORD) | (1 << PyNestMLParser.POST_RECEIVE_KEYWORD))) != 0):
                self.state = 447
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NEWLINE]:
                    self.state = 439
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                elif token in [PyNestMLParser.STATE_KEYWORD, PyNestMLParser.PARAMETERS_KEYWORD, PyNestMLParser.INTERNALS_KEYWORD, PyNestMLParser.INITIAL_VALUES_KEYWORD]:
                    self.state = 440
=======
            self.state = 432
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.STATE_KEYWORD) | (1 << PyNestMLParser.PARAMETERS_KEYWORD) | (1 << PyNestMLParser.INTERNALS_KEYWORD) | (1 << PyNestMLParser.INITIAL_VALUES_KEYWORD) | (1 << PyNestMLParser.PRE_RECEIVE_KEYWORD))) != 0):
                self.state = 430
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NEWLINE]:
                    self.state = 427
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                elif token in [PyNestMLParser.STATE_KEYWORD, PyNestMLParser.PARAMETERS_KEYWORD, PyNestMLParser.INTERNALS_KEYWORD, PyNestMLParser.INITIAL_VALUES_KEYWORD]:
                    self.state = 428
>>>>>>> origin/synapses-feature
                    self.blockWithVariables()
                    pass
                elif token in [PyNestMLParser.EQUATIONS_KEYWORD]:
                    self.state = 441
                    self.equationsBlock()
                    pass
                elif token in [PyNestMLParser.INPUT_KEYWORD]:
                    self.state = 442
                    self.inputBlock()
                    pass
                elif token in [PyNestMLParser.UPDATE_KEYWORD]:
                    self.state = 443
                    self.updateBlock()
                    pass
                elif token in [PyNestMLParser.FUNCTION_KEYWORD]:
                    self.state = 444
                    self.function()
                    pass
                elif token in [PyNestMLParser.PRE_RECEIVE_KEYWORD]:
<<<<<<< HEAD
                    self.state = 445
=======
                    self.state = 429
>>>>>>> origin/synapses-feature
                    self.preReceiveBlock()
                    pass
                elif token in [PyNestMLParser.POST_RECEIVE_KEYWORD]:
                    self.state = 446
                    self.postReceiveBlock()
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 451
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 452
=======
                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 435
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreReceiveBlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.PreReceiveBlockContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PRE_RECEIVE_KEYWORD(self):
            return self.getToken(PyNestMLParser.PRE_RECEIVE_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_preReceiveBlock

        def accept(self, visitor):
            if hasattr(visitor, "visitPreReceiveBlock"):
                return visitor.visitPreReceiveBlock(self)
            else:
                return visitor.visitChildren(self)




    def preReceiveBlock(self):

        localctx = PyNestMLParser.PreReceiveBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_preReceiveBlock)
        try:
            self.enterOuterAlt(localctx, 1)
<<<<<<< HEAD
            self.state = 454
            self.match(PyNestMLParser.PRE_RECEIVE_KEYWORD)
            self.state = 455
            self.match(PyNestMLParser.COLON)
            self.state = 456
            self.block()
            self.state = 457
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PostReceiveBlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.PostReceiveBlockContext, self).__init__(parent, invokingState)
            self.parser = parser

        def POST_RECEIVE_KEYWORD(self):
            return self.getToken(PyNestMLParser.POST_RECEIVE_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_postReceiveBlock

        def accept(self, visitor):
            if hasattr(visitor, "visitPostReceiveBlock"):
                return visitor.visitPostReceiveBlock(self)
            else:
                return visitor.visitChildren(self)




    def postReceiveBlock(self):

        localctx = PyNestMLParser.PostReceiveBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_postReceiveBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            self.match(PyNestMLParser.POST_RECEIVE_KEYWORD)
            self.state = 460
            self.match(PyNestMLParser.COLON)
            self.state = 461
            self.block()
            self.state = 462
=======
            self.state = 437
            self.match(PyNestMLParser.PRE_RECEIVE_KEYWORD)
            self.state = 438
            self.match(PyNestMLParser.COLON)
            self.state = 439
            self.block()
            self.state = 440
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockWithVariablesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.BlockWithVariablesContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.blockType = None # Token

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def STATE_KEYWORD(self):
            return self.getToken(PyNestMLParser.STATE_KEYWORD, 0)

        def PARAMETERS_KEYWORD(self):
            return self.getToken(PyNestMLParser.PARAMETERS_KEYWORD, 0)

        def INTERNALS_KEYWORD(self):
            return self.getToken(PyNestMLParser.INTERNALS_KEYWORD, 0)

        def INITIAL_VALUES_KEYWORD(self):
            return self.getToken(PyNestMLParser.INITIAL_VALUES_KEYWORD, 0)

        def declaration(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.DeclarationContext,i)


        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_blockWithVariables

        def accept(self, visitor):
            if hasattr(visitor, "visitBlockWithVariables"):
                return visitor.visitBlockWithVariables(self)
            else:
                return visitor.visitChildren(self)




    def blockWithVariables(self):

        localctx = PyNestMLParser.BlockWithVariablesContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 74, self.RULE_blockWithVariables)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 464
=======
        self.enterRule(localctx, 72, self.RULE_blockWithVariables)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
>>>>>>> origin/synapses-feature
            localctx.blockType = self._input.LT(1)
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.STATE_KEYWORD) | (1 << PyNestMLParser.PARAMETERS_KEYWORD) | (1 << PyNestMLParser.INTERNALS_KEYWORD) | (1 << PyNestMLParser.INITIAL_VALUES_KEYWORD))) != 0)):
                localctx.blockType = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
<<<<<<< HEAD
            self.state = 465
            self.match(PyNestMLParser.COLON)
            self.state = 470
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.RECORDABLE_KEYWORD))) != 0) or _la==PyNestMLParser.NAME:
                self.state = 468
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.FUNCTION_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD, PyNestMLParser.NAME]:
                    self.state = 466
                    self.declaration()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 467
=======
            self.state = 443
            self.match(PyNestMLParser.COLON)
            self.state = 448
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.RECORDABLE_KEYWORD))) != 0) or _la==PyNestMLParser.NAME:
                self.state = 446
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.FUNCTION_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD, PyNestMLParser.NAME]:
                    self.state = 444
                    self.declaration()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 445
>>>>>>> origin/synapses-feature
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 472
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 473
=======
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 451
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UpdateBlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.UpdateBlockContext, self).__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_KEYWORD(self):
            return self.getToken(PyNestMLParser.UPDATE_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_updateBlock

        def accept(self, visitor):
            if hasattr(visitor, "visitUpdateBlock"):
                return visitor.visitUpdateBlock(self)
            else:
                return visitor.visitChildren(self)




    def updateBlock(self):

        localctx = PyNestMLParser.UpdateBlockContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 76, self.RULE_updateBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(PyNestMLParser.UPDATE_KEYWORD)
            self.state = 476
            self.match(PyNestMLParser.COLON)
            self.state = 477
            self.block()
            self.state = 478
=======
        self.enterRule(localctx, 74, self.RULE_updateBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 453
            self.match(PyNestMLParser.UPDATE_KEYWORD)
            self.state = 454
            self.match(PyNestMLParser.COLON)
            self.state = 455
            self.block()
            self.state = 456
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EquationsBlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.EquationsBlockContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EQUATIONS_KEYWORD(self):
            return self.getToken(PyNestMLParser.EQUATIONS_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def inlineExpression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.InlineExpressionContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.InlineExpressionContext,i)


        def odeEquation(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.OdeEquationContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.OdeEquationContext,i)


        def odeShape(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.OdeShapeContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.OdeShapeContext,i)


        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_equationsBlock

        def accept(self, visitor):
            if hasattr(visitor, "visitEquationsBlock"):
                return visitor.visitEquationsBlock(self)
            else:
                return visitor.visitChildren(self)




    def equationsBlock(self):

        localctx = PyNestMLParser.EquationsBlockContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 78, self.RULE_equationsBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.match(PyNestMLParser.EQUATIONS_KEYWORD)
            self.state = 481
            self.match(PyNestMLParser.COLON)
            self.state = 488
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.INLINE_KEYWORD) | (1 << PyNestMLParser.RECORDABLE_KEYWORD) | (1 << PyNestMLParser.SHAPE_KEYWORD))) != 0) or _la==PyNestMLParser.NAME:
                self.state = 486
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.INLINE_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD]:
                    self.state = 482
                    self.inlineExpression()
                    pass
                elif token in [PyNestMLParser.NAME]:
                    self.state = 483
                    self.odeEquation()
                    pass
                elif token in [PyNestMLParser.SHAPE_KEYWORD]:
                    self.state = 484
                    self.odeShape()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 485
=======
        self.enterRule(localctx, 76, self.RULE_equationsBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458
            self.match(PyNestMLParser.EQUATIONS_KEYWORD)
            self.state = 459
            self.match(PyNestMLParser.COLON)
            self.state = 466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.NEWLINE) | (1 << PyNestMLParser.FUNCTION_KEYWORD) | (1 << PyNestMLParser.RECORDABLE_KEYWORD) | (1 << PyNestMLParser.SHAPE_KEYWORD))) != 0) or _la==PyNestMLParser.NAME:
                self.state = 464
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.FUNCTION_KEYWORD, PyNestMLParser.RECORDABLE_KEYWORD]:
                    self.state = 460
                    self.odeFunction()
                    pass
                elif token in [PyNestMLParser.NAME]:
                    self.state = 461
                    self.odeEquation()
                    pass
                elif token in [PyNestMLParser.SHAPE_KEYWORD]:
                    self.state = 462
                    self.odeShape()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 463
>>>>>>> origin/synapses-feature
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 490
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 491
=======
                self.state = 468
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 469
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InputBlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.InputBlockContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INPUT_KEYWORD(self):
            return self.getToken(PyNestMLParser.INPUT_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def inputPort(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.InputPortContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.InputPortContext,i)


        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NEWLINE)
            else:
                return self.getToken(PyNestMLParser.NEWLINE, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_inputBlock

        def accept(self, visitor):
            if hasattr(visitor, "visitInputBlock"):
                return visitor.visitInputBlock(self)
            else:
                return visitor.visitChildren(self)




    def inputBlock(self):

        localctx = PyNestMLParser.InputBlockContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 80, self.RULE_inputBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.match(PyNestMLParser.INPUT_KEYWORD)
            self.state = 494
            self.match(PyNestMLParser.COLON)
            self.state = 499
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.NEWLINE or _la==PyNestMLParser.NAME:
                self.state = 497
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NAME]:
                    self.state = 495
                    self.inputPort()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 496
=======
        self.enterRule(localctx, 78, self.RULE_inputBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(PyNestMLParser.INPUT_KEYWORD)
            self.state = 472
            self.match(PyNestMLParser.COLON)
            self.state = 477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.NEWLINE or _la==PyNestMLParser.NAME:
                self.state = 475
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PyNestMLParser.NAME]:
                    self.state = 473
                    self.inputLine()
                    pass
                elif token in [PyNestMLParser.NEWLINE]:
                    self.state = 474
>>>>>>> origin/synapses-feature
                    self.match(PyNestMLParser.NEWLINE)
                    pass
                else:
                    raise NoViableAltException(self)

<<<<<<< HEAD
                self.state = 501
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 502
=======
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 480
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InputPortContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.InputPortContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Token
            self.sizeParameter = None # Token
            self.isCurrent = None # Token
            self.isSpike = None # Token

        def LEFT_ANGLE_MINUS(self):
            return self.getToken(PyNestMLParser.LEFT_ANGLE_MINUS, 0)

        def NAME(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.NAME)
            else:
                return self.getToken(PyNestMLParser.NAME, i)

        def LEFT_SQUARE_BRACKET(self):
            return self.getToken(PyNestMLParser.LEFT_SQUARE_BRACKET, 0)

        def RIGHT_SQUARE_BRACKET(self):
            return self.getToken(PyNestMLParser.RIGHT_SQUARE_BRACKET, 0)

        def dataType(self):
            return self.getTypedRuleContext(PyNestMLParser.DataTypeContext,0)


        def inputQualifier(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.InputQualifierContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.InputQualifierContext,i)


        def CURRENT_KEYWORD(self):
            return self.getToken(PyNestMLParser.CURRENT_KEYWORD, 0)

        def SPIKE_KEYWORD(self):
            return self.getToken(PyNestMLParser.SPIKE_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_inputPort

        def accept(self, visitor):
            if hasattr(visitor, "visitInputPort"):
                return visitor.visitInputPort(self)
            else:
                return visitor.visitChildren(self)




    def inputPort(self):

<<<<<<< HEAD
        localctx = PyNestMLParser.InputPortContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_inputPort)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            localctx.name = self.match(PyNestMLParser.NAME)
            self.state = 508
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.LEFT_SQUARE_BRACKET:
                self.state = 505
                self.match(PyNestMLParser.LEFT_SQUARE_BRACKET)
                self.state = 506
                localctx.sizeParameter = self.match(PyNestMLParser.NAME)
                self.state = 507
                self.match(PyNestMLParser.RIGHT_SQUARE_BRACKET)


            self.state = 511
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.INTEGER_KEYWORD) | (1 << PyNestMLParser.REAL_KEYWORD) | (1 << PyNestMLParser.STRING_KEYWORD) | (1 << PyNestMLParser.BOOLEAN_KEYWORD) | (1 << PyNestMLParser.VOID_KEYWORD) | (1 << PyNestMLParser.LEFT_PAREN))) != 0) or _la==PyNestMLParser.NAME or _la==PyNestMLParser.UNSIGNED_INTEGER:
                self.state = 510
                self.dataType()


            self.state = 513
            self.match(PyNestMLParser.LEFT_ANGLE_MINUS)
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.INHIBITORY_KEYWORD or _la==PyNestMLParser.EXCITATORY_KEYWORD:
                self.state = 514
                self.inputQualifier()
                self.state = 519
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 522
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.CURRENT_KEYWORD]:
                self.state = 520
                localctx.isCurrent = self.match(PyNestMLParser.CURRENT_KEYWORD)
                pass
            elif token in [PyNestMLParser.SPIKE_KEYWORD]:
                self.state = 521
=======
        localctx = PyNestMLParser.InputLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_inputLine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482
            localctx.name = self.match(PyNestMLParser.NAME)
            self.state = 486
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.LEFT_SQUARE_BRACKET:
                self.state = 483
                self.match(PyNestMLParser.LEFT_SQUARE_BRACKET)
                self.state = 484
                localctx.sizeParameter = self.match(PyNestMLParser.NAME)
                self.state = 485
                self.match(PyNestMLParser.RIGHT_SQUARE_BRACKET)


            self.state = 489
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.INTEGER_KEYWORD) | (1 << PyNestMLParser.REAL_KEYWORD) | (1 << PyNestMLParser.STRING_KEYWORD) | (1 << PyNestMLParser.BOOLEAN_KEYWORD) | (1 << PyNestMLParser.VOID_KEYWORD) | (1 << PyNestMLParser.LEFT_PAREN))) != 0) or _la==PyNestMLParser.NAME or _la==PyNestMLParser.UNSIGNED_INTEGER:
                self.state = 488
                self.dataType()


            self.state = 491
            self.match(PyNestMLParser.LEFT_ANGLE_MINUS)
            self.state = 495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PyNestMLParser.INHIBITORY_KEYWORD or _la==PyNestMLParser.EXCITATORY_KEYWORD:
                self.state = 492
                self.inputType()
                self.state = 497
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 500
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.CURRENT_KEYWORD]:
                self.state = 498
                localctx.isCurrent = self.match(PyNestMLParser.CURRENT_KEYWORD)
                pass
            elif token in [PyNestMLParser.SPIKE_KEYWORD]:
                self.state = 499
>>>>>>> origin/synapses-feature
                localctx.isSpike = self.match(PyNestMLParser.SPIKE_KEYWORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InputQualifierContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.InputQualifierContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.isInhibitory = None # Token
            self.isExcitatory = None # Token

        def INHIBITORY_KEYWORD(self):
            return self.getToken(PyNestMLParser.INHIBITORY_KEYWORD, 0)

        def EXCITATORY_KEYWORD(self):
            return self.getToken(PyNestMLParser.EXCITATORY_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_inputQualifier

        def accept(self, visitor):
            if hasattr(visitor, "visitInputQualifier"):
                return visitor.visitInputQualifier(self)
            else:
                return visitor.visitChildren(self)




    def inputQualifier(self):

<<<<<<< HEAD
        localctx = PyNestMLParser.InputQualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_inputQualifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 526
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.INHIBITORY_KEYWORD]:
                self.state = 524
                localctx.isInhibitory = self.match(PyNestMLParser.INHIBITORY_KEYWORD)
                pass
            elif token in [PyNestMLParser.EXCITATORY_KEYWORD]:
                self.state = 525
=======
        localctx = PyNestMLParser.InputTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_inputType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.INHIBITORY_KEYWORD]:
                self.state = 502
                localctx.isInhibitory = self.match(PyNestMLParser.INHIBITORY_KEYWORD)
                pass
            elif token in [PyNestMLParser.EXCITATORY_KEYWORD]:
                self.state = 503
>>>>>>> origin/synapses-feature
                localctx.isExcitatory = self.match(PyNestMLParser.EXCITATORY_KEYWORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OutputBlockContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.OutputBlockContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.isSpike = None # Token
            self.isCurrent = None # Token

        def OUTPUT_KEYWORD(self):
            return self.getToken(PyNestMLParser.OUTPUT_KEYWORD, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def SPIKE_KEYWORD(self):
            return self.getToken(PyNestMLParser.SPIKE_KEYWORD, 0)

        def CURRENT_KEYWORD(self):
            return self.getToken(PyNestMLParser.CURRENT_KEYWORD, 0)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_outputBlock

        def accept(self, visitor):
            if hasattr(visitor, "visitOutputBlock"):
                return visitor.visitOutputBlock(self)
            else:
                return visitor.visitChildren(self)




    def outputBlock(self):

        localctx = PyNestMLParser.OutputBlockContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 86, self.RULE_outputBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.match(PyNestMLParser.OUTPUT_KEYWORD)
            self.state = 529
            self.match(PyNestMLParser.COLON)
            self.state = 532
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.SPIKE_KEYWORD]:
                self.state = 530
                localctx.isSpike = self.match(PyNestMLParser.SPIKE_KEYWORD)
                pass
            elif token in [PyNestMLParser.CURRENT_KEYWORD]:
                self.state = 531
=======
        self.enterRule(localctx, 84, self.RULE_outputBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.match(PyNestMLParser.OUTPUT_KEYWORD)
            self.state = 507
            self.match(PyNestMLParser.COLON)
            self.state = 510
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PyNestMLParser.SPIKE_KEYWORD]:
                self.state = 508
                localctx.isSpike = self.match(PyNestMLParser.SPIKE_KEYWORD)
                pass
            elif token in [PyNestMLParser.CURRENT_KEYWORD]:
                self.state = 509
>>>>>>> origin/synapses-feature
                localctx.isCurrent = self.match(PyNestMLParser.CURRENT_KEYWORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.FunctionContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.returnType = None # DataTypeContext

        def FUNCTION_KEYWORD(self):
            return self.getToken(PyNestMLParser.FUNCTION_KEYWORD, 0)

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def LEFT_PAREN(self):
            return self.getToken(PyNestMLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(PyNestMLParser.RIGHT_PAREN, 0)

        def COLON(self):
            return self.getToken(PyNestMLParser.COLON, 0)

        def block(self):
            return self.getTypedRuleContext(PyNestMLParser.BlockContext,0)


        def END_KEYWORD(self):
            return self.getToken(PyNestMLParser.END_KEYWORD, 0)

        def parameter(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PyNestMLParser.ParameterContext)
            else:
                return self.getTypedRuleContext(PyNestMLParser.ParameterContext,i)


        def dataType(self):
            return self.getTypedRuleContext(PyNestMLParser.DataTypeContext,0)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PyNestMLParser.COMMA)
            else:
                return self.getToken(PyNestMLParser.COMMA, i)

        def getRuleIndex(self):
            return PyNestMLParser.RULE_function

        def accept(self, visitor):
            if hasattr(visitor, "visitFunction"):
                return visitor.visitFunction(self)
            else:
                return visitor.visitChildren(self)




    def function(self):

        localctx = PyNestMLParser.FunctionContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 88, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 534
            self.match(PyNestMLParser.FUNCTION_KEYWORD)
            self.state = 535
            self.match(PyNestMLParser.NAME)
            self.state = 536
            self.match(PyNestMLParser.LEFT_PAREN)
            self.state = 545
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.NAME:
                self.state = 537
                self.parameter()
                self.state = 542
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PyNestMLParser.COMMA:
                    self.state = 538
                    self.match(PyNestMLParser.COMMA)
                    self.state = 539
                    self.parameter()
                    self.state = 544
=======
        self.enterRule(localctx, 86, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(PyNestMLParser.FUNCTION_KEYWORD)
            self.state = 513
            self.match(PyNestMLParser.NAME)
            self.state = 514
            self.match(PyNestMLParser.LEFT_PAREN)
            self.state = 523
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PyNestMLParser.NAME:
                self.state = 515
                self.parameter()
                self.state = 520
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PyNestMLParser.COMMA:
                    self.state = 516
                    self.match(PyNestMLParser.COMMA)
                    self.state = 517
                    self.parameter()
                    self.state = 522
>>>>>>> origin/synapses-feature
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



<<<<<<< HEAD
            self.state = 547
            self.match(PyNestMLParser.RIGHT_PAREN)
            self.state = 549
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.INTEGER_KEYWORD) | (1 << PyNestMLParser.REAL_KEYWORD) | (1 << PyNestMLParser.STRING_KEYWORD) | (1 << PyNestMLParser.BOOLEAN_KEYWORD) | (1 << PyNestMLParser.VOID_KEYWORD) | (1 << PyNestMLParser.LEFT_PAREN))) != 0) or _la==PyNestMLParser.NAME or _la==PyNestMLParser.UNSIGNED_INTEGER:
                self.state = 548
                localctx.returnType = self.dataType()


            self.state = 551
            self.match(PyNestMLParser.COLON)
            self.state = 552
            self.block()
            self.state = 553
=======
            self.state = 525
            self.match(PyNestMLParser.RIGHT_PAREN)
            self.state = 527
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PyNestMLParser.INTEGER_KEYWORD) | (1 << PyNestMLParser.REAL_KEYWORD) | (1 << PyNestMLParser.STRING_KEYWORD) | (1 << PyNestMLParser.BOOLEAN_KEYWORD) | (1 << PyNestMLParser.VOID_KEYWORD) | (1 << PyNestMLParser.LEFT_PAREN))) != 0) or _la==PyNestMLParser.NAME or _la==PyNestMLParser.UNSIGNED_INTEGER:
                self.state = 526
                localctx.returnType = self.dataType()


            self.state = 529
            self.match(PyNestMLParser.COLON)
            self.state = 530
            self.block()
            self.state = 531
>>>>>>> origin/synapses-feature
            self.match(PyNestMLParser.END_KEYWORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PyNestMLParser.ParameterContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(PyNestMLParser.NAME, 0)

        def dataType(self):
            return self.getTypedRuleContext(PyNestMLParser.DataTypeContext,0)


        def getRuleIndex(self):
            return PyNestMLParser.RULE_parameter

        def accept(self, visitor):
            if hasattr(visitor, "visitParameter"):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = PyNestMLParser.ParameterContext(self, self._ctx, self.state)
<<<<<<< HEAD
        self.enterRule(localctx, 90, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 555
            self.match(PyNestMLParser.NAME)
            self.state = 556
=======
        self.enterRule(localctx, 88, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            self.match(PyNestMLParser.NAME)
            self.state = 534
>>>>>>> origin/synapses-feature
            self.dataType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx, ruleIndex, predIndex):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[1] = self.unitType_sempred
        self._predicates[3] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def unitType_sempred(self, localctx, predIndex):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

    def expression_sempred(self, localctx, predIndex):
            if predIndex == 2:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 2)
         




