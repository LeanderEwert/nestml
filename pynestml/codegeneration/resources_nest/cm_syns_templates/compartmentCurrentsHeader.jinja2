#ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}
#define SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}

#include <stdlib.h>

#include "ring_buffer.h"

{% macro render_variable_type(variable) -%}
{%- with -%}
    {%- set symbol = variable.get_scope().resolve_to_symbol(variable.name, SymbolKind.VARIABLE) -%}
    {{ type_converter.convert(symbol.type_symbol) }}
{%- endwith -%} 
{%- endmacro %}

namespace nest
{

{%- with %}
{%- for ion_channel_name, channel_info in cm_info.items() %}

class {{ion_channel_name}}{
private:
// user-defined parameters {{ion_channel_name}} channel (maximal conductance, reversal potential)
    {%- for pure_variable_name, variable_info in channel_info["gating_variables"].items() %}
    // state variable {{pure_variable_name -}}
        {%- set variable = variable_info["state_variable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    {{render_variable_type(variable)}} {{ variable.name}} = {{printer.print_expression(rhs_expression) -}};
    {%- endfor %}
// state variables {{ion_channel_name}} channel
    {%- for variable_type, variable_info in channel_info["channel_parameters"].items() %}
    // parameter {{variable_type -}}
        {%- set variable = variable_info["parameter_block_variable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    {{render_variable_type(variable)}} {{ variable.name}} = {{printer.print_expression(rhs_expression) -}};
    {%- endfor %}
    
public:
    // constructor, destructor
    {{ion_channel_name}}();
    {{ion_channel_name}}(const DictionaryDatum& channel_params);
    ~{{ion_channel_name}}(){};
    
    // initialization
    void init(){
    {%- for pure_variable_name, variable_info in channel_info["gating_variables"].items() -%}
        {%- set variable = variable_info["state_variable"] -%}
        {%- set rhs_expression = variable_info["rhs_expression"] -%}
        {{ variable.name}} = {{printer.print_expression(rhs_expression) }};
    {%- endfor -%}
    };

    // numerical integration step
    std::pair< double, double > f_numstep( const double v_comp, const double dt );

    // function declarations
{%- for pure_variable_name, state_variable_info in channel_info["gating_variables"].items() %}
{% for function_type, function_info in state_variable_info["expected_functions"].items() %}
    {{printer.print_function_declaration(function_info["ASTFunction"]) -}};
{% endfor %}
{%- endfor %}

};
{% endfor -%}
{% endwith -%}

/*
{%- with %}
{%- for synapse_name, synapse_info in syns_info.items() %}

class {{synapse_name}}{
private:
  // user defined parameters
  {%- for param_name, param_declaration in synapse_info["parameters_used"].items() %}
  double {{param_name}}_ = {{printer.print_expression(param_declaration.get_expression())}};
  {%- endfor %}

  // assigned variables
  double g_norm_ = 1.0;

  // state variables
  double g_r_ = 0., g_d_ = 0.;

  // spike buffer
  std::shared_ptr< RingBuffer >  b_spikes_;

public:
  // constructor, destructor
  {{synapse_name}}(std::shared_ptr< RingBuffer >  b_spikes, const DictionaryDatum& receptor_params);
  ~{{synapse_name}}(){};

  // initialization of the state variables
  void init()
  {
    g_r_ = 0.; g_d_ = 0.;
    b_spikes_->clear();
  };

  // numerical integration step
  std::pair< double, double > f_numstep( const double v_comp, const double dt, const long lag );
};


{% endfor -%}
{% endwith -%}
*/


class AMPA{
private:
  // user defined parameters
  double e_rev_ = 0.0; // mV -> renamed to e_AMPA_
  double tau_r_ = 0.2, tau_d_ = 3.; // ms -> renamed to tau_syn_AMPA_

  // assigned variables
  double g_norm_ = 1.0;

  // state variables
  double g_r_ = 0., g_d_ = 0.;

  // spike buffer
  std::shared_ptr< RingBuffer >  b_spikes_;

public:
  // constructor, destructor
  AMPA(std::shared_ptr< RingBuffer >  b_spikes, const DictionaryDatum& receptor_params);
  ~AMPA(){};

  // initialization of the state variables
  void init()
  {
    g_r_ = 0.; g_d_ = 0.;
    b_spikes_->clear();
  };

  // numerical integration step
  std::pair< double, double > f_numstep( const double v_comp, const double dt, const long lag );
};


class GABA{
private:
  // user defined parameters
  double e_rev_ = 0.0; // mV
  double tau_r_ = 0.2, tau_d_ = 10.; // ms

  // assigned variables
  double g_norm_ = 1.0;

  // state variables
  double g_r_ = 0., g_d_ = 0.;

  // spike buffer
  std::shared_ptr< RingBuffer > b_spikes_;

public:
  // constructor, destructor
  GABA(std::shared_ptr< RingBuffer >  b_spikes, const DictionaryDatum& receptor_params);
  ~GABA(){};

  // initialization of the state variables
  void init()
  {
    g_r_ = 0.; g_d_ = 0.;
    b_spikes_->clear();
  };

  // numerical integration step
  std::pair< double, double > f_numstep( const double v_comp, const double dt, const long lag );
};


class NMDA{
private:
  // user defined parameters
  double e_rev_ = 0.0; // mV
  double tau_r_ = 0.2, tau_d_ = 43.; // ms

  // assigned variables
  double g_norm_ = 1.0;

  // state variables
  double g_r_ = 0., g_d_ = 0.;

  // spike buffer
  std::shared_ptr< RingBuffer >  b_spikes_;

public:
  // constructor, destructor
  NMDA(std::shared_ptr< RingBuffer >  b_spikes, const DictionaryDatum& receptor_params);
  ~NMDA(){};

  // initialization of the state variables
  void init(){
    g_r_ = 0.; g_d_ = 0.;
    b_spikes_->clear();
  };

  // numerical integration step
  std::pair< double, double > f_numstep( const double v_comp, const double dt, const long lag );

  // synapse specific funtions
  inline double NMDAsigmoid( double v_comp )
  {
    return 1. / ( 1. + 0.3 * std::exp( -.1 * v_comp ) );
  };
  inline double d_NMDAsigmoid_dv( double v_comp )
  {
    return 0.03 * std::exp( -0.1 * v_comp ) / std::pow( 0.3 * std::exp( -0.1*v_comp ) + 1.0, 2 );
  };
};


class AMPA_NMDA{
private:
  // user defined parameters
  double e_rev_ = 0.0; // mV
  double tau_r_AMPA_ = 0.2, tau_d_AMPA_ = 43.; // ms
  double tau_r_NMDA_ = 0.2, tau_d_NMDA_ = 43.; // ms
  double NMDA_ratio_ = 2.0;

  // assigned variables
  double g_norm_AMPA_ = 1.0;
  double g_norm_NMDA_ = 1.0;

  // state variables
  double g_r_AMPA_ = 0., g_d_AMPA_ = 0.;
  double g_r_NMDA_ = 0., g_d_NMDA_ = 0.;

  // spike buffer
  std::shared_ptr< RingBuffer >  b_spikes_;

public:
  // constructor, destructor
  AMPA_NMDA(std::shared_ptr< RingBuffer >  b_spikes, const DictionaryDatum& receptor_params);
  ~AMPA_NMDA(){};

  // initialization of the state variables
  void init()
  {
    g_r_AMPA_ = 0.; g_d_AMPA_ = 0.;
    g_r_NMDA_ = 0.; g_d_NMDA_ = 0.;
    b_spikes_->clear();
  };

  // numerical integration step
  std::pair< double, double > f_numstep( const double v_comp, const double dt, const long lag );

  // synapse specific funtions
  inline double NMDAsigmoid( double v_comp )
  {
    return 1. / ( 1. + 0.3 * std::exp( -.1 * v_comp ) );
  };
  inline double d_NMDAsigmoid_dv( double v_comp )
  {
    return 0.03 * std::exp( -0.1 * v_comp ) / std::pow( 0.3 * std::exp( -0.1*v_comp ) + 1.0, 2 );
  };
};


{%- set channel_suffix = "_chan_" %}

class CompartmentCurrents{{cm_unique_suffix}} {
private:
  // ion channels
{% with %}
  {%- for ion_channel_name, channel_info in cm_info.items() %}
  {{ion_channel_name}} {{ion_channel_name}}{{channel_suffix}};
  {% endfor -%}
{% endwith %}  

  // synapses
  std::vector < AMPA > AMPA_syns_;
  std::vector < GABA > GABA_syns_;
  std::vector < NMDA > NMDA_syns_;
  std::vector < AMPA_NMDA > AMPA_NMDA_syns_;

public:
  CompartmentCurrents{{cm_unique_suffix}}(){};
  CompartmentCurrents{{cm_unique_suffix}}(const DictionaryDatum& channel_params)
  {
  {%- with %}
    {%- for ion_channel_name, channel_info in cm_info.items() %}
    {{ion_channel_name}}{{channel_suffix}} = {{ion_channel_name}}( channel_params );
    {% endfor -%}
  {% endwith -%}  
  };
  ~CompartmentCurrents{{cm_unique_suffix}}(){};

  void init(){
    // initialization of the ion channels
  {%- with %}
    {%- for ion_channel_name, channel_info in cm_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.init();
    {% endfor -%}
  {% endwith -%}  
  
    // initialization of AMPA synapses
    for( auto syn_it = AMPA_syns_.begin();
         syn_it != AMPA_syns_.end();
         ++syn_it )
    {
      syn_it->init();

    }
    // initialization of GABA synapses
    for( auto syn_it = GABA_syns_.begin();
         syn_it != GABA_syns_.end();
         ++syn_it )
    {
      syn_it->init();
    }
    // initialization of NMDA synapses
    for( auto syn_it = NMDA_syns_.begin();
         syn_it != NMDA_syns_.end();
         ++syn_it )
    {
      syn_it->init();
    }
    // initialization of AMPA_NMDA synapses
    for( auto syn_it = AMPA_NMDA_syns_.begin();
         syn_it != AMPA_NMDA_syns_.end();
         ++syn_it )
    {
      syn_it->init();
    }
  }

  void add_synapse_with_buffer( const std::string& type, std::shared_ptr< RingBuffer > b_spikes, const DictionaryDatum& receptor_params )
  {
    if ( type == "AMPA" )
    {
      AMPA syn( b_spikes, receptor_params );
      AMPA_syns_.push_back( syn );
    }
    else if ( type == "GABA" )
    {
      GABA syn( b_spikes, receptor_params );
      GABA_syns_.push_back( syn );
    }
    else if ( type == "NMDA" )
    {
      NMDA syn( b_spikes, receptor_params );
      NMDA_syns_.push_back( syn );
    }
    else if ( type == "AMPA_NMDA" )
    {
      AMPA_NMDA syn( b_spikes, receptor_params );
      AMPA_NMDA_syns_.push_back( syn );
    }
    else
    {
      assert( false );
    }
  };

  std::pair< double, double > f_numstep( const double v_comp, const double dt, const long lag )
  {
    std::pair< double, double > gi(0., 0.);
    double g_val = 0.;
    double i_val = 0.;
    
  {%- with %}
    {%- for ion_channel_name, channel_info in cm_info.items() %}
    // contribution of {{ion_channel_name}} channel
    gi = {{ion_channel_name}}{{channel_suffix}}.f_numstep( v_comp, dt );

    g_val += gi.first;
    i_val += gi.second;
    
    {% endfor -%}
  {% endwith -%}  

    // contribution of AMPA synapses
    for( auto syn_it = AMPA_syns_.begin();
         syn_it != AMPA_syns_.end();
         ++syn_it )
    {
      gi = syn_it->f_numstep( v_comp, dt, lag );

      g_val += gi.first;
      i_val += gi.second;
    }
    // contribution of GABA synapses
    for( auto syn_it = GABA_syns_.begin();
         syn_it != GABA_syns_.end();
         ++syn_it )
    {
      gi = syn_it->f_numstep( v_comp, dt, lag );

      g_val += gi.first;
      i_val += gi.second;
    }
    // contribution of NMDA synapses
    for( auto syn_it = NMDA_syns_.begin();
         syn_it != NMDA_syns_.end();
         ++syn_it )
    {
      gi = syn_it->f_numstep( v_comp, dt, lag );

      g_val += gi.first;
      i_val += gi.second;
    }
    // contribution of AMPA_NMDA synapses
    for( auto syn_it = AMPA_NMDA_syns_.begin();
         syn_it != AMPA_NMDA_syns_.end();
         ++syn_it )
    {
      gi = syn_it->f_numstep( v_comp, dt, lag );

      g_val += gi.first;
      i_val += gi.second;
    }

    return std::make_pair(g_val, i_val);
  };
};

} // namespace

#endif /* #ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }} */
