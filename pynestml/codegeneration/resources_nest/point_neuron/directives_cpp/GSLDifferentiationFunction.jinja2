{#
  Creates GSL implementation of the differentiation step for the system of ODEs.
-#}
extern "C" inline int {{neuronName}}_dynamics{% if ast.get_args() | length > 0 %}_{{ utils.integrate_odes_args_str_from_function_call(ast) }}{% endif %}(double, const double ode_state[], double f[], void* pnode)
{
  typedef {{neuronName}}::State_ State_;
  // get access to node so we can almost work as in a member function
  assert( pnode );
  const {{neuronName}}& node = *( reinterpret_cast< {{neuronName}}* >( pnode ) );

  // ode_state[] here is---and must be---the state vector supplied by the integrator,
  // not the state vector in the node, node.S_.ode_state[].

{%- for eq_block in neuron.get_equations_blocks() %}
{%-     for ode in eq_block.get_declarations() %}
{%-         for inline_expr in utils.get_inline_expression_symbols(ode) %}
{%-             if not inline_expr.is_equation() %}
{%-                 set declaring_expr = inline_expr.get_declaring_expression() %}
  double {{ printer.print(utils.get_state_variable_by_name(astnode, inline_expr)) }} = {{ gsl_printer.print(declaring_expr) }};
{%-             endif %}
{%-         endfor %}
{%-     endfor %}
{%- endfor %}


{%- set var_names = numeric_state_variables %}
{%- if paired_synapse is defined %}
{%-     set tmp = var_names.extend(numeric_state_variables_moved) %}
{%- endif %}

{%- for variable_name in var_names %}
{%-   set update_expr = numeric_update_expressions[variable_name] %}
{%-   set variable_symbol = utils.resolve_to_variable_symbol_in_blocks(variable_name, neuron.get_state_blocks()) %}
  f[State_::{{ variable_symbol.get_symbol_name() }}] = {% if ast.get_args() | length > 0 %}{% if variable_name in utils.integrate_odes_args_strs_from_function_call(ast) %}{{ gsl_printer.print(update_expr) }}{% else %}0{% endif %}{% else %}{{ gsl_printer.print(update_expr) }}{% endif %};
{%- endfor %}

{%- if numeric_solver == "rk45" %}
  return GSL_SUCCESS;
{%- else %}
  return 0;
{%- endif %}
}
