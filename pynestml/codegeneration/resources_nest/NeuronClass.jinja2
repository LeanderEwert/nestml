{#
/*
*  NeuronClass.jinja2
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */{%- else -%}{%- endif -%}
/*
*  {{neuronName}}.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*  {{now}}
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "{{neuronName}}.h"

{% set stateSize = neuron.get_non_function_initial_values_symbols()|length %}
/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<{{neuronName}}> {{neuronName}}::recordablesMap_;

namespace nest
{
  // Override the create() method with one call to RecordablesMap::insert_()
  // for each quantity to be recorded.
  template <> void RecordablesMap<{{neuronName}}>::create(){
  // use standard names where you can for consistency!

  // initial values for state variables not in ODE or kernel
{%- filter indent(2,True) %}
{%- for variable in neuron.get_state_non_alias_symbols() %}
{%-   include "directives/RecordCallback.jinja2" %}
{%- endfor %}
{%- endfilter %}

  // initial values for state variables in ODE or kernel
{%- filter indent(2,True) %}
{%- for variable in neuron.get_initial_values_non_alias_symbols() %}
{%-   if not is_delta_kernel(neuron.get_kernel_by_name(variable.name)) %}
{%-     include "directives/RecordCallback.jinja2" %}
{%-   endif %}
{%- endfor %}
{%- endfilter %}
  
  // internals
{%- filter indent(2,True) %}
{%- for variable in neuron.get_internal_symbols() %}
{%-   include "directives/RecordCallback.jinja2" %}
{%- endfor %}
{%- endfilter %}
  
  // parameters
{%- filter indent(2,True) %}
{%- for variable in neuron.get_parameter_symbols() %}
{%-   include "directives/RecordCallback.jinja2" %}
{%- endfor %}
{%- endfilter %}

  // function symbols
{%- filter indent(2,True) %}
{%- for funcsym in neuron.get_function_symbols() %}
{%-   with variable = funcsym %}
{%-     include "directives/RecordCallback.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
  }
}

/* ----------------------------------------------------------------
 * Default constructors defining default parameters and state
 * Note: the implementation is empty. The initialization is of variables
 * is a part of the {{neuronName}}'s constructor.
 * ---------------------------------------------------------------- */
{{neuronName}}::Parameters_::Parameters_(){}

{{neuronName}}::State_::State_(){}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

{{neuronName}}::Buffers_::Buffers_({{neuronName}} &n):
  logger_(n)
{%- if neuron.get_multiple_receptors()|length > 1 -%}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{%- endif -%}
{%- if useGSL -%}
  , __s( 0 ), __c( 0 ), __e( 0 )
{%- endif -%}
{
  // Initialization of the remaining members is deferred to
  // init_buffers_().
}

{{neuronName}}::Buffers_::Buffers_(const Buffers_ &, {{neuronName}} &n):
  logger_(n)
{%- if neuron.get_multiple_receptors()|length > 1 -%}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{%- endif -%}
{%- if useGSL -%}
  , __s( 0 ), __c( 0 ), __e( 0 )
{%- endif -%}
{
  // Initialization of the remaining members is deferred to
  // init_buffers_().
}

/* ----------------------------------------------------------------
 * Default and copy constructor for node, and destructor
 * ---------------------------------------------------------------- */
{{neuronName}}::{{neuronName}}() : StructuralPlasticityNode(), P_(), S_(), B_(*this)
{
  recordablesMap_.create();

  calibrate();

{%- if useGSL %}
  // use a default "good enough" value for the absolute error. It can be adjusted via `node.set()`
  P_.__gsl_error_tol = 1e-3;
{%- endif %}

  // initial values for parameters
{%- filter indent(2, True) %}
{%- for parameter in neuron.get_parameter_non_alias_symbols() -%}
{%-   with variable = parameter %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}

  // initial values for state variables not in ODE or kernel
{%- filter indent(2,True) %}
{%- for state in neuron.get_state_non_alias_symbols() %}
{%-   with variable = state %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}

  // initial values for state variables in ODE or kernel
{%- filter indent(2,True) %}
{%- for init in neuron.get_initial_values_non_alias_symbols() %}
{%-   if not is_delta_kernel(neuron.get_kernel_by_name(init.name)) %}
{%-     with variable = init -%}
{%-       include "directives/MemberInitialization.jinja2" %}
{%-     endwith %}
{%-   endif %}
{%- endfor %}
{%- endfilter %}

{%- if dyadic_synapse_partner is defined %}
  // state variables for archiving state for dyadic synaptic partner
  n_incoming_ = 0;
  max_delay_ = 0;
  last_spike_ = -1.;

  // cache initial values
{%- for funcsym in neuron.get_function_symbols() %}
{%- with var = funcsym %}
{%- if "__for" in funcsym.get_symbol_name() %}
{{var.get_symbol_name()}}__iv = {{names.getter(var)}}();
{%- endif %}
{%- endwith %}
{%- endfor %}                        
{%- endif %}
}

{{neuronName}}::{{neuronName}}(const {{neuronName}}& __n):
  StructuralPlasticityNode(), P_(__n.P_), S_(__n.S_), B_(__n.B_, *this) {
  // copy parameter struct P_
{%- filter indent(2, True) %}
{%- for parameter in neuron.get_parameter_non_alias_symbols() %}
P_.{{names.name(parameter)}} = __n.P_.{{names.name(parameter)}};
{%- endfor %}
{%- endfilter %}

  // copy state struct S_
{%- filter indent(2, True) %}
{%- for state in neuron.get_state_non_alias_symbols() %}
S_.{{names.name(state)}} = __n.S_.{{names.name(state)}};
{%- endfor %}
{%- endfilter %}

{%- filter indent(2, True) %}
{%- for init in neuron.get_initial_values_non_alias_symbols() %}
{%-   if not is_delta_kernel(neuron.get_kernel_by_name(init.name)) %}
S_.{{names.name(init)}} = __n.S_.{{names.name(init)}};
{%-   endif %}
{%- endfor %}
{%- for internal in neuron.get_internal_non_alias_symbols() %}
V_.{{names.name(internal)}} = __n.V_.{{names.name(internal)}};
{%- endfor %}
{%- endfilter %}

{%- if dyadic_neuron_partner is defined %}
  n_incoming_ = __n.n_incoming;
  max_delay_ = __n.max_delay_;
  last_spike_ = __n.last_spike_;
{%- endif %}
}

{{neuronName}}::~{{neuronName}}(){ {% if useGSL %}
  // GSL structs may not have been allocated, so we need to protect destruction
  if (B_.__s)
    gsl_odeiv_step_free( B_.__s );
  if (B_.__c)
    gsl_odeiv_control_free( B_.__c );
  if (B_.__e)
    gsl_odeiv_evolve_free( B_.__e );{% endif %}
}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void {{neuronName}}::init_state_(const Node& proto){
  const {{neuronName}}& pr = downcast<{{neuronName}}>(proto);
  S_ = pr.S_;
}

{% if useGSL %}
{% include "directives/GSLDifferentiationFunction.jinja2" %}
{% endif %}

void {{neuronName}}::init_buffers_(){
  {% for buffer in neuron.get_input_buffers() -%}
  {{ printer.print_buffer_initialization(buffer) }}
  {% endfor %}
  B_.logger_.reset(); // includes resize

{%- if dyadic_neuron_partner is defined %}
  clear_history();
{%- endif %}

  {% if useGSL %}
  if ( B_.__s == 0 ){
    B_.__s = gsl_odeiv_step_alloc( gsl_odeiv_step_rkf45, {{stateSize}} );
  } else {
    gsl_odeiv_step_reset( B_.__s );
  }

  if ( B_.__c == 0 ){
    B_.__c = gsl_odeiv_control_y_new( P_.__gsl_error_tol, 0.0 );
  } else {
    gsl_odeiv_control_init( B_.__c, P_.__gsl_error_tol, 0.0, 1.0, 0.0 );
  }

  if ( B_.__e == 0 ){
    B_.__e = gsl_odeiv_evolve_alloc( {{stateSize}} );
  } else {
    gsl_odeiv_evolve_reset( B_.__e );
  }

  B_.__sys.function = {{neuronName}}_dynamics;
  B_.__sys.jacobian = NULL;
  B_.__sys.dimension = {{stateSize}};
  B_.__sys.params = reinterpret_cast< void* >( this );
  B_.__step = nest::Time::get_resolution().get_ms();
  B_.__integration_step = nest::Time::get_resolution().get_ms();{% endif %}
}

void {{neuronName}}::calibrate_variables(bool exclude_timestep) {
if (exclude_timestep) {
{%- filter indent(2,True) %}
{%- for variable in neuron.get_internal_non_alias_symbols() %}
{%- if variable.name != "__h" %}
{%-   include "directives/Calibrate.jinja2" %}
{%- endif %}
{%- endfor %}
{%- endfilter %}

{%- filter indent(2,True) %}
{%- for variable in neuron.get_state_non_alias_symbols() %}
{%-   if variable.has_vector_parameter() %}
{%-     include "directives/Calibrate.jinja2" %}
{%-   endif %}
{%- endfor %}
{%- endfilter %}
}
else {
{%- filter indent(2,True) %}
{%- for variable in neuron.get_internal_non_alias_symbols() %}
{%-   include "directives/Calibrate.jinja2" %}
{%- endfor %}
{%- endfilter %}

{%- filter indent(2,True) %}
{%- for variable in neuron.get_state_non_alias_symbols() %}
{%-   if variable.has_vector_parameter() %}
{%-     include "directives/Calibrate.jinja2" %}
{%-   endif %}
{%- endfor %}
{%- endfilter %}
}
}

void {{neuronName}}::calibrate() {
  B_.logger_.init();

  calibrate_variables();

{%- for buffer in neuron.get_input_buffers() %}
{%-   if buffer.has_vector_parameter() %}
  B_.{{buffer.get_symbol_name()}}.resize(P_.{{buffer.get_vector_parameter()}});
  B_.{{buffer.get_symbol_name()}}_grid_sum_.resize(P_.{{buffer.get_vector_parameter()}});
{%-   endif %}
{%- endfor %}
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*
 {{neuron.print_dynamics_comment('*')}}
 */
void {{neuronName}}::update(nest::Time const & origin,const long from, const long to){
{%- if useGSL %}
//  double __t = 0;
{%- endif %}

  for ( long lag = from ; lag < to ; ++lag ) {
{%- for inputPort in neuron.get_input_buffers() %}
{%-   if inputPort.has_vector_parameter() %}
    for (long i=0; i < P_.{{inputPort.get_vector_parameter()}}; ++i){
      B_.{{names.buffer_value(inputPort)}}[i] = get_{{names.name(inputPort)}}()[i].get_value(lag);
    }
{%-   else %}
    B_.{{names.buffer_value(inputPort)}} = get_{{names.name(inputPort)}}().get_value(lag);
{%-   endif %}
{%- endfor %}

    // NESTML generated code for the update block:

{%- if neuron.get_update_blocks() %}
{%- filter indent(2,True) %}
{%- set dynamics = neuron.get_update_blocks() %}
{%- with ast = dynamics.get_block() %}
{%-   include "directives/Block.jinja2" %}
{%- endwith %}
{%- endfilter %}
{%- endif %}

    // voltage logging
    B_.logger_.record_data(origin.get_steps()+lag);
  }

}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void {{neuronName}}::handle(nest::DataLoggingRequest& e){
  B_.logger_.handle(e);
}

{%- for function in neuron.get_functions() %}
{{printer.print_function_definition(function, neuronName)}}
{
{%-   filter indent(2,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
}
{%- endfor %}

{%- if is_spike_input %}
void {{neuronName}}::handle(nest::SpikeEvent &e){
  assert(e.get_delay_steps() > 0);
{%- if neuron.is_multisynapse_spikes() %}
{%-   set spikeBuffer = neuron.get_spike_buffers()[0] %}
  B_.{{spikeBuffer.get_symbol_name()}}[e.get_rport() - 1].add_value(
    e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
    e.get_weight() * e.get_multiplicity() );
{%- elif neuron.get_multiple_receptors()|length > 1 %}
  assert( e.get_rport() < static_cast< int >( B_.spike_inputs_.size() ) );

  B_.spike_inputs_[ e.get_rport() ].add_value(
    e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
    e.get_weight() * e.get_multiplicity() );
{%- else %}
  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();
{%-   for buffer in neuron.get_spike_buffers() %}
{%-     if buffer.is_excitatory() %}
  if ( weight >= 0.0 ){ // excitatory
    get_{{buffer.get_symbol_name()}}().
        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                       weight * multiplicity );
  }
{%-     endif %}
{%-     if buffer.is_inhibitory() %}
  if ( weight < 0.0 ){ // inhibitory
    get_{{buffer.get_symbol_name()}}().
        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                      {% if buffer.is_conductance_based() %} // ensure conductance is positive {% endif %}
                      {% if buffer.is_conductance_based() %} -1 * {% endif %} weight * multiplicity );
  }
{%-     endif -%}
{%-   endfor %}
{%- endif %}
}
{%- endif %}

{%- if is_current_input %}
void {{neuronName}}::handle(nest::CurrentEvent& e){
  assert(e.get_delay_steps() > 0);

  const double current = e.get_current();		// we assume that in NEST, this returns a current in pA
  const double weight = e.get_weight();

{%- for buffer in neuron.get_current_buffers() %}
  get_{{buffer.get_symbol_name()}}().add_value(
               e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
               weight * current );
{%- endfor %}
}
{%- endif %}



{%- if dyadic_synapse_partner is defined %}


inline double
{{neuronName}}::get_spiketime_ms() const
{
  return last_spike_;
}


void
{{neuronName}}::register_stdp_connection( double t_first_read, double delay )
{
  // Mark all entries in the deque, which we will not read in future as read by
  // this input input, so that we safely increment the incoming number of
  // connections afterwards without leaving spikes in the history.
  // For details see bug #218. MH 08-04-22

  for ( std::deque< histentry__ >::iterator runner = history_.begin();
        runner != history_.end() and ( t_first_read - runner->t_ > -1.0 * nest::kernel().connection_manager.get_stdp_eps() );
        ++runner )
  {
    ( runner->access_counter_ )++;
  }

  n_incoming_++;

  max_delay_ = std::max( delay, max_delay_ );
}


void
{{neuronName}}::get_history__( double t1,
  double t2,
  std::deque< histentry__ >::iterator* start,
  std::deque< histentry__ >::iterator* finish )
{
  *finish = history_.end();
  if ( history_.empty() )
  {
    *start = *finish;
    return;
  }
  std::deque< histentry__ >::reverse_iterator runner = history_.rbegin();
  const double t2_lim = t2 + nest::kernel().connection_manager.get_stdp_eps();
  const double t1_lim = t1 + nest::kernel().connection_manager.get_stdp_eps();
  while ( runner != history_.rend() and runner->t_ >= t2_lim )
  {
    ++runner;
  }
  *finish = runner.base();
  while ( runner != history_.rend() and runner->t_ >= t1_lim )
  {
    runner->access_counter_++;
    ++runner;
  }
  *start = runner.base();
}

void
{{neuronName}}::set_spiketime( nest::Time const& t_sp, double offset )
{
    StructuralPlasticityNode::set_spiketime( t_sp, offset );

    unsigned int num_transferred_variables = 0;
{#- for var in transferred_variables #}
{%- for funcsym in neuron.get_function_symbols() %}
{%- with var = funcsym %}
{%- if "__for" in funcsym.get_symbol_name() %}
    ++num_transferred_variables;
{%- endif %}
{%- endwith %}
{%- endfor %}





    const double t_sp_ms = t_sp.get_ms() - offset;

    if ( n_incoming_ )
    {
        // prune all spikes from history which are no longer needed
        // only remove a spike if:
        // - its access counter indicates it has been read out by all connected
        //     STDP synapses, and
        // - there is another, later spike, that is strictly more than
        //     (max_delay_ + eps) away from the new spike (at t_sp_ms)
        while ( history_.size() > 1 )
        {
            const double next_t_sp = history_[ 1 ].t_;
            if ( history_.front().access_counter_ >= n_incoming_ * num_transferred_variables
                and t_sp_ms - next_t_sp > max_delay_ + nest::kernel().connection_manager.get_stdp_eps() )
            {
                history_.pop_front();
            }
            else
            {
                break;
            }
        }

        if (history_.size() > 0) {
            assert(history_.back().t_ == last_spike_);

{%- for var in numeric_state_variables_moved|sort %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = history_.back().{{var}}_;
{%- endfor %}
        }
        else {
{%- for var in numeric_state_variables_moved|sort %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = 0.;
{%- endfor %}
        }


        /**
         * update state variables transferred from synapse from `last_spike_` to `t_sp_ms`
        **/



        const double old___h = V_.__h;
        V_.__h = t_sp_ms - last_spike_;
        assert(V_.__h > 0);
        calibrate_variables(true);
{%- filter indent(6, True) %}
{#
  Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.
#}
{% if uses_analytic_solver -%}
{% for variable_name in analytic_state_variables_moved|sort -%}
{%   set update_expr = update_expressions[variable_name] -%}
  double {{variable_name}}__tmp = {{printer.print_expression(update_expr)}};
{% endfor -%}
{% endif -%}



{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}   // XXX: TODO: jinja2 exclude synapse->neuron moved variables here
{%- endif %}


/* replace analytically solvable variables with precisely integrated values  */
{% if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}
{% if uses_analytic_solver -%}
{% for variable_name in analytic_state_variables_moved|sort -%}
{%   set variable_sym = analytic_variable_symbols_moved[variable_name] -%}
    {{printer.print_origin(variable_sym)}}{{names.name(variable_sym)}} = {{variable_name}}__tmp;
{% endfor -%}
{% endif -%}

{%- endfilter %}
        V_.__h = old___h;
        calibrate_variables(true);


        /**
         * apply spike updates
        **/

{%- for _, spike_update in dyad_spike_updates.items() %}
        S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(spike_update.get_variable().get_complete_name(), SymbolKind.VARIABLE))}} += 1.;
{%- endfor %}

    last_spike_ = t_sp_ms;
    history_.push_back( histentry__( last_spike_
{%- for var in numeric_state_variables_moved|sort %}
    , get_{{var}}()
{%- endfor %}
, 0
 ) );
  }
  else
  {
    last_spike_ = t_sp_ms;
  }
}


void
{{neuronName}}::clear_history()
{
  last_spike_ = -1.0;
  history_.clear();
}


{#- for var in transferred_variables #}
  {%- for funcsym in neuron.get_function_symbols() %}
  {%- with var = funcsym %}
  {%- if "__for" in funcsym.get_symbol_name() %}

double
{{neuronName}}::get_{{var.get_symbol_name()}}( double t )
{
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var.get_symbol_name()}}: getting value at t = " << t << std::endl;
#endif
  // case when the neuron has not yet spiked
  if ( history_.empty() )
  {
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var.get_symbol_name()}}: \thistory empty, returning initial value = " << {{var.get_symbol_name()}}__iv << std::endl;
#endif
    // return initial value
    return {{var.get_symbol_name()}}__iv;
  }

  // search for the latest post spike in the history buffer that came strictly before `t`
  int i = history_.size() - 1;
  while ( i >= 0 )
  {
    if ( t - history_[ i ].t_ > nest::kernel().connection_manager.get_stdp_eps() )
    {
#ifdef DEBUG
        std::cout<<"{{neuronName}}::get_{{var.get_symbol_name()}}: \tspike occurred at history[i].t_ = " << history_[i].t_ << std::endl;
#endif

        /**
         * update state variables transferred from synapse from `history[i].t_` to `t`
        **/

{%- for var in numeric_state_variables_moved %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = history_[ i ].{{var}}_;
{%- endfor %}

        const double old___h = V_.__h;
        V_.__h = t - history_[i].t_;
        assert(V_.__h > 0);
        calibrate_variables(true);
{%- filter indent(6, True) %}
{#
  Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}
{%- if uses_analytic_solver %}
{%- for variable_name in analytic_state_variables_moved|sort %}
{%-   set update_expr = update_expressions[variable_name] %}
  double {{variable_name}}__tmp = {{printer.print_expression(update_expr)}};
{%- endfor %}
{%- endif %}

{%- if purely_numeric_state_variables_moved|length > 0 %}
    double ode_state_tmp[STATE_VEC_SIZE];

    for (int i = 0; i < STATE_VEC_SIZE; ++i) {
        ode_state_tmp[i] = S_.ode_state[i];
    }

{%- filter indent(2,True) %}
{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

{%- for variable_name in numeric_state_variables_moved|sort %}
{%- if not variable_name in analytic_state_variables_moved %}
S_.ode_state[State_::{{variable_name}}] = ode_state_tmp[State_::{{variable_name}}];
{%- endif %}
{%- endfor %}
{%- endfilter %}

{%- endif %}







/* replace analytically solvable variables with precisely integrated values  */
{% if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif %}
{% if uses_analytic_solver -%}
{% for variable_name in analytic_state_variables_moved|sort -%}
{%   set variable_sym = analytic_variable_symbols_moved[variable_name] -%}
    {{printer.print_origin(variable_sym)}}{{names.name(variable_sym)}} = {{variable_name}}__tmp;
{% endfor -%}
{% endif -%}

{%- endfilter %}
        V_.__h = old___h;
        calibrate_variables(true);

#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var.get_symbol_name()}}: \treturning " << {{names.getter(var)}}() << std::endl;
#endif
  return {{names.getter(var)}}();

      // {{declarations.print_variable_type(var)}}
    }
    --i;
  }
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var.get_symbol_name()}}: \tfall-through, returning initial value = " << {{var.get_symbol_name()}}__iv << std::endl;
#endif

  // this case occurs when the trace was requested at a time precisely at or before the first spike in the history
  // return initial value
    return {{var.get_symbol_name()}}__iv;
}
  {%- endif -%}
  {%- endwith -%}
  {%- endfor %}


{%- endif %}
