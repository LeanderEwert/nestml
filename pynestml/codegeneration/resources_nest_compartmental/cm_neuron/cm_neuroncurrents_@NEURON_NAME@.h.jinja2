{#-
cm_compartmentcurrents_@NEURON_NAME@.h.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}

{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif -%}
{%- import 'directives_cpp/FunctionDeclaration.jinja2' as function_declaration with context %}
#ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}
#define SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}

#include <stdlib.h>
#include <vector>

#include "ring_buffer.h"

{% macro render_variable_type(variable) -%}
{%- with -%}
    {%- set symbol = variable.get_scope().resolve_to_symbol(variable.name, SymbolKind.VARIABLE) -%}
    {{ types_printer.print(symbol.type_symbol) }}
{%- endwith -%}
{%- endmacro %}

namespace nest
{

///////////////////////////////////// channels

{%- with %}
{%- for ion_channel_name, channel_info in chan_info.items() %}

class {{ion_channel_name}}{{cm_unique_suffix}}{
private:
    // states
    {%- for pure_variable_name, variable_info in channel_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // parameters
    {%- for pure_variable_name, variable_info in channel_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // ion-channel root-inline value
    std::vector< double > i_tot_{{ion_channel_name}} = {};

public:
    // constructor, destructor
    {{ion_channel_name}}{{cm_unique_suffix}}(){};
    ~{{ion_channel_name}}{{cm_unique_suffix}}(){};

    void new_channel(std::size_t comp_ass);
    void new_channel(std::size_t comp_ass, const DictionaryDatum& channel_params);

    //number of channels
    std::size_t neuron_{{ ion_channel_name }}_channel_count = 0;

    std::vector< long > compartment_association = {};

    // initialization channel
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    void calibrate() {
{%- else %}
    void pre_run_hook() {
{%- endif %}
    };

    void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);

    // numerical integration step
    std::pair< std::vector< double >, std::vector< double > > f_numstep( std::vector< double > v_comp{% for ode in channel_info["Dependencies"]["concentrations"] %}, std::vector< double > {{ode.lhs.name}}{% endfor %}{% if channel_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["receptors"] %}, std::vector< double > {{inline.variable_name}}{% endfor %}{% if channel_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["channels"] %}, std::vector< double > {{inline.variable_name}}{% endfor %});

    // function declarations

{%- for function in channel_info["Functions"] %}
    {{ function_declaration.FunctionDeclaration(function) }};
{%- endfor %}

    // root_inline getter
    void get_currents_per_compartment(std::vector< double >& compartment_to_current);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};
{% endfor -%}
{% endwith -%}


///////////////////////////////////////////// concentrations

{%- with %}
{%- for concentration_name, concentration_info in conc_info.items() %}

class {{ concentration_name }}{{cm_unique_suffix}}{
private:
    // parameters
    {%- for pure_variable_name, variable_info in concentration_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // states
    {%- for pure_variable_name, variable_info in concentration_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // concentration value (root-ode state)
    std::vector< double > {{concentration_name}} = {};

public:
    // constructor, destructor
    {{ concentration_name }}{{cm_unique_suffix}}(){};
    ~{{ concentration_name }}{{cm_unique_suffix}}(){};

    void new_concentration(std::size_t comp_ass);
    void new_concentration(std::size_t comp_ass, const DictionaryDatum& concentration_params);

    //number of channels
    std::size_t neuron_{{ concentration_name }}_concentration_count = 0;

    std::vector< long > compartment_association = {};

    // initialization concentration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    void calibrate() {
{%- else %}
    void pre_run_hook() {
{%- endif %}
    for(std::size_t concentration_id = 0; concentration_id < neuron_{{ concentration_name }}_concentration_count; concentration_id++){
    // states
    {%- for pure_variable_name, variable_info in concentration_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
        {{ variable.name }}[concentration_id] = {{ printer_no_origin.print_with_indices(rhs_expression, "concentration_id") }};
    {%- endfor %}
    }
    };
    void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);

    // numerical integration step
    void f_numstep( std::vector< double > v_comp{% for ode in concentration_info["Dependencies"]["concentrations"] %}, std::vector< double > {{ode.lhs.name}}{% endfor %}{% if concentration_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["receptors"] %}, std::vector< double > {{inline.variable_name}}{% endfor %}{% if concentration_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["channels"] %}, std::vector< double > {{inline.variable_name}}{% endfor %});

    // function declarations
{%- for function in concentration_info["Functions"] %}
    {{ function_declaration.FunctionDeclaration(function) }};
{%- endfor %}

    // root_ode getter
    void get_concentrations_per_compartment(std::vector< double >& compartment_to_concentration);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};
{% endfor -%}
{% endwith -%}


////////////////////////////////////////////////// synapses

{% macro render_time_resolution_variable(synapse_info) -%}
{# we assume here that there is only one such variable ! #}
{%- with %}
{%- for analytic_helper_name, analytic_helper_info in synapse_info["analytic_helpers"].items() -%}
{%- if analytic_helper_info["is_time_resolution"] -%}
    {{ analytic_helper_name }}
{%- endif -%}
{%- endfor -%}
{% endwith %}
{%- endmacro %}

{%- with %}
{%- for synapse_name, synapse_info in syns_info.items() %}

class {{synapse_name}}{{cm_unique_suffix}}{
private:
  // global synapse index
  long syn_idx = 0;

  // propagators, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["propagators"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // kernel state variables, initialized via pre_run_hook() or calibrate()
  {%- for convolution, convolution_info in synapse_info["convolutions"].items() %}
  {%- for state_variable_name, state_variable_info in convolution_info["analytic_solution"]["kernel_states"].items()%}
  std::vector< double > {{state_variable_name}};
  {%- endfor %}
  {%- endfor %}

  // user defined parameters, initialized via pre_run_hook() or calibrate()
  {%- for param_name, param_declaration in synapse_info["Parameters"].items() %}
  std::vector< double > {{param_name}};
  {%- endfor %}

      // states
    {%- for pure_variable_name, variable_info in synapse_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
  std::vector<{{ render_variable_type(variable) }}> {{ variable.name }} = {}
        };
    {%- endfor %}

  std::vector< double > i_tot_{{synapse_name}} = {};

  // user declared internals in order they were declared, initialized via pre_run_hook() or calibrate()
  {%- for internal_name, internal_declaration in synapse_info["internals_used_declared"] %}
  std::vector< double > {{internal_name}};
  {%- endfor %}



  // spike buffer
  std::vector< RingBuffer >* {{synapse_info["buffer_name"]}}_;

public:
  // constructor, destructor
  {{synapse_name}}{{cm_unique_suffix}}(){};
  ~{{synapse_name}}{{cm_unique_suffix}}(){};

  void new_synapse(std::size_t comp_ass);
  void new_synapse(std::size_t comp_ass, const DictionaryDatum& synapse_params);

  //number of synapses
  std::size_t neuron_{{ synapse_name }}_synapse_count = 0;

  std::vector< long > compartment_association = {};

  // numerical integration step
  std::pair< std::vector< double >, std::vector< double > > f_numstep( std::vector< double > v_comp, const long lag {% for ode in synapse_info["Dependencies"]["concentrations"] %}, std::vector< double > {{ode.lhs.name}}{% endfor %}{% if synapse_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in synapse_info["Dependencies"]["receptors"] %}, std::vector< double > {{inline.variable_name}}{% endfor %}{% if synapse_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in synapse_info["Dependencies"]["channels"] %}, std::vector< double > {{inline.variable_name}}{% endfor %});

  // calibration
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate();
{%- else %}
  void pre_run_hook();
{%- endif %}
  void append_recordables(std::map< Name, double* >* recordables, const long compartment_idx);
  void set_buffer_ptr( std::vector< RingBuffer >& syn_buffers )
  {
        {{synapse_info["buffer_name"]}}_ = &syn_buffers;
  };

  // function declarations
  {%- for function in synapse_info["Functions"] %}
  {{ function_declaration.FunctionDeclaration(function, "") -}};

  {% endfor %}

    // root_inline getter
    void get_currents_per_compartment(std::vector< double >& compartment_to_current);

    std::vector< double > distribute_shared_vector(std::vector< double > shared_vector);

};

{% endfor -%}
{% endwith -%}


///////////////////////////////////////////// currents

{%- set channel_suffix = "_chan_" %}
{%- set concentration_suffix = "_conc_" %}
{%- set synapse_suffix = "_syn_" %}

class NeuronCurrents{{cm_unique_suffix}} {
private:
  //mechanisms
  // ion channels
{% with %}
  {%- for ion_channel_name, channel_info in chan_info.items() %}
  {{ion_channel_name}}{{cm_unique_suffix}} {{ion_channel_name}}{{channel_suffix}};
  {% endfor -%}
{% endwith %}
  // concentrations
{% with %}
  {%- for concentration_name, concentration_info in conc_info.items() %}
  {{concentration_name}}{{cm_unique_suffix}} {{concentration_name}}{{concentration_suffix}};
  {% endfor -%}
{% endwith %}
  // synapses
{% with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
  {{synapse_name}}{{cm_unique_suffix}} {{synapse_name}}{{synapse_suffix}};
  {% endfor -%}
{% endwith %}

  //number of compartments
  std::size_t compartment_number = 0;

  //interdependency shared reference vectors
  // ion channels
{% with %}
  {%- for ion_channel_name, channel_info in chan_info.items() %}
  std::vector < double > {{ion_channel_name}}{{channel_suffix}}_shared_current;
  {% endfor -%}
{% endwith %}
  // concentrations
{% with %}
  {%- for concentration_name, concentration_info in conc_info.items() %}
  std::vector < double > {{concentration_name}}{{concentration_suffix}}_shared_concentration;
  {% endfor -%}
{% endwith %}
  // synapses
{% with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
  std::vector < double > {{synapse_name}}{{synapse_suffix}}_shared_current;
  {% endfor -%}
{% endwith %}

  //compartment gi states
  std::vector < std::pair < double, double > > comps_gi;

public:
  NeuronCurrents{{cm_unique_suffix}}(){};
{#-
  explicit NeuronCurrents{{cm_unique_suffix}}(const DictionaryDatum& compartment_params)
  {
  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}} = {{ion_channel_name}}{{cm_unique_suffix}}( compartment_params );
    {% endfor -%}
  {% endwith -%}

  {%- with %}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{ concentration_name }}{{concentration_suffix}} = {{ concentration_name }}{{cm_unique_suffix}}( compartment_params );
    {% endfor -%}
  {% endwith -%}
  };
#}
  ~NeuronCurrents{{cm_unique_suffix}}(){};

{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate() {
{%- else %}
  void pre_run_hook() {
{%- endif %}
    // initialization of ion channels
  {%- with %}
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.calibrate();
    {% endfor -%}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.calibrate();
    {% endfor -%}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{synapse_name}}{{synapse_suffix}}.calibrate();
    {% endfor -%}
{%- else %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.pre_run_hook();
    {% endfor -%}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.pre_run_hook();
    {% endfor -%}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{synapse_name}}{{synapse_suffix}}.pre_run_hook();
    {% endfor -%}
{%- endif %}
  {% endwith -%}
  };

  void add_mechanism( const std::string& type, const std::size_t compartment_id)
  {
  {%- with %}
    bool mech_found = false;
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    if ( type == "{{ion_channel_name}}" )
    {
      {{ion_channel_name}}{{channel_suffix}}.new_channel(compartment_id);
      mech_found = true;
    }
  {% endfor -%}

  {%- for concentration_name, concentration_info in conc_info.items() %}
    if ( type == "{{concentration_name}}" )
    {
      {{concentration_name}}{{concentration_suffix}}.new_concentration(compartment_id);
      mech_found = true;
    }
  {% endfor -%}

  {%- for synapse_name, synapse_info in syns_info.items() %}
    if ( type == "{{synapse_name}}" )
    {
      {{synapse_name}}{{synapse_suffix}}.new_synapse(compartment_id);
      mech_found = true;
    }
  {% endfor -%}
  {% endwith -%}
    if(!mech_found)
    {
      assert( false );
    }
  };

  void add_mechanism( const std::string& type, const std::size_t compartment_id, const DictionaryDatum& mechanism_params)
  {
   {%- with %}
    bool mech_found = false;
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    if ( type == "{{ion_channel_name}}" )
    {
      {{ion_channel_name}}{{channel_suffix}}.new_channel(compartment_id, mechanism_params);
      mech_found = true;
    }
  {% endfor -%}

  {%- for concentration_name, concentration_info in conc_info.items() %}
    if ( type == "{{concentration_name}}" )
    {
      {{concentration_name}}{{concentration_suffix}}.new_concentration(compartment_id, mechanism_params);
      mech_found = true;
    }
  {% endfor -%}

  {%- for synapse_name, synapse_info in syns_info.items() %}
    if ( type == "{{synapse_name}}" )
    {
      {{synapse_name}}{{synapse_suffix}}.new_synapse(compartment_id, mechanism_params);
      mech_found = true;
    }
  {% endfor -%}
  {% endwith -%}
    if(!mech_found)
    {
      assert( false );
    }
  };

  void add_compartment(){
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->add_mechanism("{{ ion_channel_name }}", compartment_number);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->add_mechanism("{{ concentration_name }}", compartment_number);
    {% endfor -%}

    compartment_number++;

    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->{{ion_channel_name}}{{channel_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->{{concentration_name}}{{concentration_suffix}}_shared_concentration.push_back(0.0);
    {% endfor -%}

    {%- for synapse_name, synapse_info in syns_info.items() %}
    this->{{synapse_name}}{{synapse_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

  };

  void add_compartment(const DictionaryDatum& compartment_params){
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->add_mechanism("{{ ion_channel_name }}", compartment_number, compartment_params);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->add_mechanism("{{ concentration_name }}", compartment_number, compartment_params);
    {% endfor -%}

    compartment_number++;

    {%- for ion_channel_name, channel_info in chan_info.items() %}
    this->{{ion_channel_name}}{{channel_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}

    {%- for concentration_name, concentration_info in conc_info.items() %}
    this->{{concentration_name}}{{concentration_suffix}}_shared_concentration.push_back(0.0);
    {% endfor -%}

    {%- for synapse_name, synapse_info in syns_info.items() %}
    this->{{synapse_name}}{{synapse_suffix}}_shared_current.push_back(0.0);
    {% endfor -%}
  };

  void add_receptor_info( ArrayDatum& ad, long compartment_index )
  {

    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( std::size_t syn_it = 0; syn_it != {{synapse_name}}{{synapse_suffix}}.neuron_{{synapse_name}}_synapse_count; syn_it++)
    {
      DictionaryDatum dd = DictionaryDatum( new Dictionary );
      def< long >( dd, names::receptor_idx, syn_it );
      def< long >( dd, names::comp_idx, compartment_index );
      def< std::string >( dd, names::receptor_type, "{{synapse_name}}" );
      ad.push_back( dd );
    }
    {% endfor -%}
    {% endwith -%}
  };

  void set_syn_buffers( std::vector< RingBuffer >& syn_buffers)
  {
    // spike buffers for synapses

    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
      {{synapse_name}}{{ synapse_suffix }}.set_buffer_ptr( syn_buffers );
    {% endfor -%}
    {% endwith %}

  };

  std::map< Name, double* > get_recordables( const long compartment_idx )
  {
    std::map< Name, double* > recordables;

    // append ion channel state variables to recordables
    {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}
    {% endwith %}

    // append concentration state variables to recordables
    {%- with %}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{concentration_name}}{{concentration_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}
    {% endwith %}

    // append synapse state variables to recordables
{%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    {{synapse_name}}{{synapse_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor %}
    {% endwith %}

    return recordables;
  };

  std::vector< std::pair< double, double > > f_numstep( std::map< size_t, double > v_comps, const long lag )
  {
    std::vector< std::pair< double, double > > comp_to_gi(compartment_number, std::make_pair(0., 0.));
{%- for synapse_name, synapse_info in syns_info.items() %}
    {{synapse_name}}{{synapse_suffix}}.get_currents_per_compartment({{synapse_name}}{{synapse_suffix}}_shared_current);
{% endfor %}
{%- for concentration_name, concentration_info in conc_info.items() %}
    {{ concentration_name }}{{concentration_suffix}}.get_concentrations_per_compartment({{concentration_name}}{{concentration_suffix}}_shared_concentration);
{% endfor -%}
{%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.get_currents_per_compartment({{ion_channel_name}}{{channel_suffix}}_shared_current);
{% endfor -%}

  //transform to vector:
  std::vector< double > v_comp_vec = {};
    for(size_t i = 0; i < v_comps.size(); i++){
        v_comp_vec.push_back(v_comps[i]);
    }

  {%- with %}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    // computation of {{ concentration_name }} concentration
    {{ concentration_name }}{{concentration_suffix}}.f_numstep( {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector(v_comp_vec){% for ode in concentration_info["Dependencies"]["concentrations"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if concentration_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["receptors"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{inline.variable_name}}{{synapse_suffix}}_shared_current){% endfor %}{% if concentration_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["channels"] %}, {{ concentration_name }}{{concentration_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %});

    {% endfor -%}
  {% endwith -%}

    std::pair< std::vector< double >, std::vector< double > > gi_mech;

  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    // contribution of {{ion_channel_name}} channel
    gi_mech = {{ion_channel_name}}{{channel_suffix}}.f_numstep( {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector(v_comp_vec){% for ode in channel_info["Dependencies"]["concentrations"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if channel_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["receptors"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{inline.variable_name}}{{synapse_suffix}}_shared_current){% endfor %}{% if channel_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["channels"] %}, {{ion_channel_name}}{{channel_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %});

    for(std::size_t chan_id = 0; chan_id < {{ion_channel_name}}{{channel_suffix}}.neuron_{{ ion_channel_name }}_channel_count; chan_id++){
        comp_to_gi[{{ion_channel_name}}{{channel_suffix}}.compartment_association[chan_id]].first += gi_mech.first[chan_id];
        comp_to_gi[{{ion_channel_name}}{{channel_suffix}}.compartment_association[chan_id]].second += gi_mech.second[chan_id];
    }
    {% endfor -%}
  {% endwith -%}

  {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    // contribution of {{synapse_name}} synapses
    gi_mech = {{synapse_name}}{{synapse_suffix}}.f_numstep( {{synapse_name}}{{synapse_suffix}}.distribute_shared_vector(v_comp_vec), lag {% for ode in synapse_info["Dependencies"]["concentrations"] %}, {{synapse_name}}{{synapse_suffix}}.distribute_shared_vector({{ode.lhs.name}}{{concentration_suffix}}_shared_concentration){% endfor %}{% if synapse_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in synapse_info["Dependencies"]["receptors"] %}, {{synapse_name}}{{synapse_suffix}}.distribute_shared_vector({{inline.variable_name}}{{synapse_suffix}}_shared_current){% endfor %}{% if synapse_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in synapse_info["Dependencies"]["channels"] %}, {{synapse_name}}{{synapse_suffix}}.distribute_shared_vector({{inline.variable_name}}{{channel_suffix}}_shared_current){% endfor %});

    for(std::size_t syn_id = 0; syn_id < {{synapse_name}}{{synapse_suffix}}.neuron_{{ synapse_name }}_synapse_count; syn_id++){
        comp_to_gi[{{synapse_name}}{{synapse_suffix}}.compartment_association[syn_id]].first += gi_mech.first[syn_id];
        comp_to_gi[{{synapse_name}}{{synapse_suffix}}.compartment_association[syn_id]].second += gi_mech.second[syn_id];
    }
    {% endfor -%}
  {% endwith -%}

    return comp_to_gi;
  };
};

} // namespace

#endif /* #ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }} */
