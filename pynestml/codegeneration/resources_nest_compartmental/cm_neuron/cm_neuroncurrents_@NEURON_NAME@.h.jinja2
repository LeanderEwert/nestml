{#-
cm_compartmentcurrents_@NEURON_NAME@.h.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */ {% endif -%}
{%- import 'directives/FunctionDeclaration.jinja2' as function_declaration with context %}
#ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}
#define SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }}

#include <stdlib.h>

#include "ring_buffer.h"

{% macro render_variable_type(variable) -%}
{%- with -%}
    {%- set symbol = variable.get_scope().resolve_to_symbol(variable.name, SymbolKind.VARIABLE) -%}
    {{ types_printer.print(symbol.type_symbol) }}
{%- endwith -%}
{%- endmacro %}

namespace nest
{

{%- with %}
{%- for ion_channel_name, channel_info in chan_info.items() %}

class {{ion_channel_name}}{{cm_unique_suffix}}{
private:
    // states
    {%- for pure_variable_name, variable_info in channel_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // parameters
    {%- for pure_variable_name, variable_info in channel_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
    std::vector< {{ render_variable_type(variable) }} > {{ variable.name }} = {};
    {%- endfor %}

    // ion-channel root-inline value
    std::vector< double > i_tot_{{ion_channel_name}} = {};

    //number of channels
    std::size_t neuron_{{ ion_channel_name }}_channel_count = 0;

    std::vector< std::size_t > compartment_association = {};

public:
    // constructor, destructor
    {{ion_channel_name}}{{cm_unique_suffix}}();
    ~{{ion_channel_name}}{{cm_unique_suffix}}(){};

    std::size_t new_channel(std::size_t comp_ass);
    std::size_t new_channel(std::size_t comp_ass, const DictionaryDatum& channel_params);

    // initialization channel
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    void calibrate() {
{%- else %}
    void pre_run_hook() {
{%- endif %}
        for(std::size_t i = 0; i < neuron_{{ ion_channel_name }}_channel_count; i++){
            // states
    {%- for pure_variable_name, variable_info in channel_info["States"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
            {{ variable.name }}[comp_id] = {{ printer_no_origin.print_with_indices(rhs_expression, "channel_id") }};
    {%- endfor %}

            // parameters
    {%- for pure_variable_name, variable_info in channel_info["Parameters"].items() %}
        {%- set variable = variable_info["ASTVariable"] %}
        {%- set rhs_expression = variable_info["rhs_expression"] %}
            {{ variable.name }}[comp_id] = {{ printer_no_origin.print_with_indices(rhs_expression, "channel_id") }};
    {%- endfor %}
        }
    };

    void append_recordables(std::map< Name, double* >* recordables,
                            const long compartment_idx, std::size_t channel_id);

    // numerical integration step
    std::pair< double, double > f_numstep( const double v_comp{% for ode in channel_info["Dependencies"]["concentrations"] %}, double {{ode.lhs.name}}{% endfor %}{% if channel_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["receptors"] %}, double {{inline.variable_name}}{% endfor %}{% if channel_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["channels"] %}, double {{inline.variable_name}}{% endfor %});

    // function declarations

{%- for function in channel_info["Functions"] %}
    {{ function_declaration.FunctionDeclaration(function) }};
{%- endfor %}

    // root_inline getter
    double get_current_{{ion_channel_name}}(std::size_t channel_id);

};
{% endfor -%}
{% endwith -%}

///////////////////////////////////////////// currents

{%- set channel_suffix = "_chan_" %}

class NeuronCurrents{{cm_unique_suffix}} {
private:
  // ion channels
{% with %}
  {%- for ion_channel_name, channel_info in chan_info.items() %}
  {{ion_channel_name}}{{cm_unique_suffix}} {{ion_channel_name}}{{channel_suffix}};
  {% endfor -%}
{% endwith %}

public:
  NeuronCurrents{{cm_unique_suffix}}(){};
  explicit NeuronCurrents{{cm_unique_suffix}}(const DictionaryDatum& compartment_params)
  {
  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}} = {{ion_channel_name}}{{cm_unique_suffix}}( compartment_params );
    {% endfor -%}
  {% endwith -%}

{%- with %}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    {{ concentration_name }}{{concentration_suffix}} = {{ concentration_name }}{{cm_unique_suffix}}( compartment_params );
    {% endfor -%}
  {% endwith -%}
  };
  ~NeuronCurrents{{cm_unique_suffix}}(){};

{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
  void calibrate() {
{%- else %}
  void pre_run_hook() {
{%- endif %}
    // initialization of ion channels
  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
{%- if nest_version.startswith("v2") or nest_version.startswith("v3.1") or nest_version.startswith("v3.2") or nest_version.startswith("v3.3") %}
    {{ion_channel_name}}{{channel_suffix}}.calibrate();
{%- else %}
    {{ion_channel_name}}{{channel_suffix}}.pre_run_hook();
{%- endif %}
    {% endfor -%}
  {% endwith -%}
  };

  void add_mechanism( const std::string& type, const std::size_t compartment_id)
  {
  {%- with %}
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    {% if not loop.first %}else{% endif %} if ( type == "{{ion_channel_name}}" )
    {
      {{ion_channel_name}}{{channel_suffix}}.new_channel(compartment_id);
    }
  {% endfor -%}
  {% endwith -%}
    else
    {
      assert( false );
    }
  };

  void add_mechanism( const std::string& type, const std::size_t compartment_id, const DictionaryDatum& mechanism_params)
  {
  {%- with %}
  {%- for ion_channel_name, channel_info in chan_info.items() %}
    {% if not loop.first %}else{% endif %} if ( type == "{{ion_channel_name}}" )
    {
      {{ion_channel_name}}{{channel_suffix}}.new_channel(compartment_id, mechanism_params);
    }
  {% endfor -%}
  {% endwith -%}
    else
    {
      assert( false );
    }
  };

  void
  add_receptor_info( ArrayDatum& ad, const long compartment_index )
  {

    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( auto syn_it = {{synapse_name}}_syns_.begin(); syn_it != {{synapse_name}}_syns_.end(); syn_it++)
    {
      DictionaryDatum dd = DictionaryDatum( new Dictionary );
      def< long >( dd, names::receptor_idx, syn_it->get_syn_idx() );
      def< long >( dd, names::comp_idx, compartment_index );
      def< std::string >( dd, names::receptor_type, "{{synapse_name}}" );
      ad.push_back( dd );
    }
    {% endfor -%}
    {% endwith -%}
  };

  void
  set_syn_buffers( std::vector< RingBuffer >& syn_buffers )
  {
    // spike buffers for synapses
    {%- with %}
    {%- for synapse_name, synapse_info in syns_info.items() %}
    for( auto syn_it = {{synapse_name}}_syns_.begin(); syn_it != {{synapse_name}}_syns_.end(); syn_it++)
      syn_it->set_buffer_ptr( syn_buffers );
    {% endfor -%}
    {% endwith -%}
  };

  std::map< Name, double* >
  get_recordables( const long compartment_idx )
  {
    std::map< Name, double* > recordables;

    // append ion channel state variables to recordables
    {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    {{ion_channel_name}}{{channel_suffix}}.append_recordables( &recordables, compartment_idx );
    {% endfor -%}
    {% endwith -%}

    return recordables;
  };

  std::pair< double, double >
  f_numstep( const double v_comp, const long lag )
  {
    std::pair< double, double > gi(0., 0.);
    double g_val = 0.;
    double i_val = 0.;
{%- for synapse_name, synapse_info in syns_info.items() %}
    double {{synapse_name}}{{channel_suffix}}current_sum = 0;
    for( auto syn_it = {{synapse_name}}_syns_.begin();
         syn_it != {{synapse_name}}_syns_.end();
         ++syn_it )
    {
        {{synapse_name}}{{channel_suffix}}current_sum += syn_it->get_current_{{synapse_name}}();
    }
{% endfor %}

  {%- with %}
    {%- for concentration_name, concentration_info in conc_info.items() %}
    // computation of {{ concentration_name }} concentration
    {{ concentration_name }}{{concentration_suffix}}.f_numstep( v_comp{% for ode in concentration_info["Dependencies"]["concentrations"] %}, {{ode.lhs.name}}{{concentration_suffix}}.get_concentration_{{ode.lhs.name}}(){% endfor %}{% if concentration_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["receptors"] %}, {{inline.variable_name}}{{channel_suffix}}_current_sum{% endfor %}{% if concentration_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in concentration_info["Dependencies"]["channels"] %}, {{inline.variable_name}}{{channel_suffix}}.get_current_{{inline.variable_name}}(){% endfor %});

    {% endfor -%}
  {% endwith -%}

  {%- with %}
    {%- for ion_channel_name, channel_info in chan_info.items() %}
    // contribution of {{ion_channel_name}} channel
    gi = {{ion_channel_name}}{{channel_suffix}}.f_numstep( v_comp{% for ode in channel_info["Dependencies"]["concentrations"] %}, {{ode.lhs.name}}{{concentration_suffix}}.get_concentration_{{ode.lhs.name}}(){% endfor %}{% if channel_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["receptors"] %}, {{inline.variable_name}}{{channel_suffix}}_current_sum{% endfor %}{% if channel_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in channel_info["Dependencies"]["channels"] %}, {{inline.variable_name}}{{channel_suffix}}.get_current_{{inline.variable_name}}(){% endfor %});

    g_val += gi.first;
    i_val += gi.second;

    {% endfor -%}
  {% endwith -%}

  {%- with %}
  {%- for synapse_name, synapse_info in syns_info.items() %}
    // contribution of {{synapse_name}} synapses
    for( auto syn_it = {{synapse_name}}_syns_.begin();
         syn_it != {{synapse_name}}_syns_.end();
         ++syn_it )
    {
      gi = syn_it->f_numstep( v_comp, lag {% for ode in synapse_info["Dependencies"]["concentrations"] %}, {{ode.lhs.name}}{{concentration_suffix}}.get_concentration_{{ode.lhs.name}}(){% endfor %}{% if synapse_info["Dependencies"]["receptors"]|length %}
                        {% endif %}{% for inline in synapse_info["Dependencies"]["receptors"] %}, {{inline.variable_name}}{{channel_suffix}}_current_sum{% endfor %}{% if synapse_info["Dependencies"]["channels"]|length %}
                        {% endif %}{% for inline in synapse_info["Dependencies"]["channels"] %}, {{inline.variable_name}}{{channel_suffix}}.get_current{{inline.variable_name}}(){% endfor %});

      g_val += gi.first;
      i_val += gi.second;
    }
  {% endfor -%}
  {% endwith -%}

    return std::make_pair(g_val, i_val);
  };
};

} // namespace

#endif /* #ifndef SYNAPSES_NEAT_H_{{cm_unique_suffix | upper }} */
